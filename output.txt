----------------------------------------
### FILE: moderate.ts ###
----------------------------------------
"use server";

import { GoogleGenerativeAI } from "@google/generative-ai";
import { createClient } from "@supabase/supabase-js";

// 管理者権限クライアント
const getAdminSupabase = () => {
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
  const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;
  return createClient(supabaseUrl, serviceRoleKey);
};

// ▼▼▼ ルール設定 ▼▼▼
const VIOLATION_LIMIT = 5;      // 30分以内に5回でアウト
const VIOLATION_WINDOW_MIN = 30; // 30分

const SUSPENSION_LIMIT = 3;     // 30日以内に3回凍結でBAN
const SUSPENSION_WINDOW_DAYS = 30; // 30日

const SUSPENSION_HOURS = 24;    // 凍結時間は24時間

// ユーザーの状態を判定・更新するロジック
async function checkAndPenaltyUser(supabase: any, userId: string) {
  const { data: p } = await supabase
    .from("profiles")
    .select("*")
    .eq("user_id", userId)
    .single();

  const now = new Date();
  
  // 1. 永久BANチェック
  if (p.is_banned) {
    return { 
      allowed: false, 
      msg: "あなたのアカウントは永久停止されています。" 
    };
  }

  // 2. 凍結期間中かチェック
  if (p.suspended_until) {
    const suspendedUntil = new Date(p.suspended_until);
    if (now < suspendedUntil) {
      const remainingHours = Math.ceil((suspendedUntil.getTime() - now.getTime()) / (1000 * 60 * 60));

      // ▼▼▼ 追加：日本時間に変換して表示する ▼▼▼
      const jstTime = suspendedUntil.toLocaleString("ja-JP", { 
        timeZone: "Asia/Tokyo",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit"
      });

      return { 
        allowed: false, 
        msg: `アカウントは一時凍結されています。\n解除予定: ${jstTime} (JST)\nあと約 ${remainingHours} 時間です。` 
      };
    }
  }

  // 3. 期間リセット処理（違反カウント）
  // 最初の違反から30分以上経っていたら、違反カウントを0に戻す
  if (p.first_violation_at) {
    const firstViolated = new Date(p.first_violation_at);
    const diffMin = (now.getTime() - firstViolated.getTime()) / (1000 * 60);
    if (diffMin > VIOLATION_WINDOW_MIN) {
      await supabase.from("profiles").update({ violation_count: 0, first_violation_at: null }).eq("user_id", userId);
      p.violation_count = 0; // メモリ上もリセット
    }
  }

  // 4. 期間リセット処理（凍結カウント）
  // 最初の凍結から30日以上経っていたら、凍結カウントを0に戻す
  if (p.first_suspension_at) {
    const firstSuspended = new Date(p.first_suspension_at);
    const diffDays = (now.getTime() - firstSuspended.getTime()) / (1000 * 60 * 60 * 24);
    if (diffDays > SUSPENSION_WINDOW_DAYS) {
      await supabase.from("profiles").update({ suspension_count: 0, first_suspension_at: null }).eq("user_id", userId);
    }
  }

  return { allowed: true, profile: p };
}

// 違反時の加算処理
async function addViolation(supabase: any, userId: string, profile: any) {
  const now = new Date();
  const updates: any = {};

  // 違反カウントを増やす
  const newViolationCount = (profile.violation_count || 0) + 1;
  updates.violation_count = newViolationCount;

  // 初回なら時間を記録
  if (newViolationCount === 1) {
    updates.first_violation_at = now.toISOString();
  }

  // ▼▼▼ 24時間凍結の発動判定 ▼▼▼
  if (newViolationCount >= VIOLATION_LIMIT) {
    const newSuspensionCount = (profile.suspension_count || 0) + 1;
    updates.suspension_count = newSuspensionCount;
    updates.violation_count = 0; // 違反カウントはリセット
    updates.first_violation_at = null;
    
    // 24時間後まで凍結
    const until = new Date(now.getTime() + (SUSPENSION_HOURS * 60 * 60 * 1000));
    updates.suspended_until = until.toISOString();

    // 凍結回数の期間管理
    if (newSuspensionCount === 1) {
      updates.first_suspension_at = now.toISOString();
    }

    // ▼▼▼ 永久BANの発動判定 ▼▼▼
    if (newSuspensionCount >= SUSPENSION_LIMIT) {
      updates.is_banned = true;
      updates.suspended_until = null; // 永久なので日付不要
    }
  }

  await supabase.from("profiles").update(updates).eq("user_id", userId);
  
  return { 
    newViolationCount, 
    isSuspended: updates.suspended_until ? true : false,
    isBanned: updates.is_banned ? true : false
  };
}


// ▼▼▼ メイン関数（テキスト） ▼▼▼
export async function checkContentSafety(text: string, userId: string) {
  const supabase = getAdminSupabase();
  
  // 1. ユーザー状態確認
  const status = await checkAndPenaltyUser(supabase, userId);
  if (!status.allowed) {
    return { isSafe: false, reason: status.msg };
  }

  // 2. AIチェック
  const apiKey = process.env.GEMINI_API_KEY;
  if (!apiKey) return { isSafe: false, reason: "システムエラー" };

  const genAI = new GoogleGenerativeAI(apiKey);
  const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash" });

  const prompt = `
    テキスト: "${text}"
    判定ルール: VRChatイベント募集として不適切ならNG。JSON返答。
    { "isSafe": boolean, "reason": "短い理由" }
  `;

  try {
    const result = await model.generateContent(prompt);
    const response = await result.response;
    const jsonString = response.text().match(/\{[\s\S]*\}/)?.[0] || "{}";
    const resultJson = JSON.parse(jsonString);

    // 3. NGだった場合の処理
    if (resultJson.isSafe === false) {
      const penaltyResult = await addViolation(supabase, userId, status.profile);
      
      let warningMsg = `理由: ${resultJson.reason}`;

      if (penaltyResult.isBanned) {
         warningMsg = "違反が重なったため、アカウントが永久停止されました。";
      } else if (penaltyResult.isSuspended) {
         warningMsg = "短時間に違反が集中したため、24時間の利用制限がかかりました。";
      } else {
         // ★ここで残り回数を表示！
         const remaining = VIOLATION_LIMIT - penaltyResult.newViolationCount;
         warningMsg += `\n\n⚠️ あと ${remaining} 回 違反すると、24時間の利用制限がかかります。`;
      }

      return { isSafe: false, reason: warningMsg };
    }

    return { isSafe: true, reason: "" };

  } catch (error) {
    console.error("AI Check Error:", error);
    return { isSafe: true, reason: "" }; 
  }
}

// ▼▼▼ メイン関数（画像） ▼▼▼
export async function checkImageSafety(imageUrl: string, userId: string) {
  const supabase = getAdminSupabase();

  // 1. ユーザー状態確認
  const status = await checkAndPenaltyUser(supabase, userId);
  if (!status.allowed) {
    return { isSafe: false, reason: status.msg };
  }

  // 2. AIチェック
  const apiKey = process.env.GEMINI_API_KEY;
  if (!apiKey) return { isSafe: false, reason: "システムエラー" };

  const genAI = new GoogleGenerativeAI(apiKey);
  const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash" });

  try {
    const imageResp = await fetch(imageUrl);
    const arrayBuffer = await imageResp.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);
    const base64Image = buffer.toString("base64");
    const mimeType = imageResp.headers.get("content-type") || "image/jpeg";

    const prompt = `
      画像チェック。不適切ならNG。JSON返答。
      { "isSafe": boolean, "reason": "短い理由" }
    `;

    const result = await model.generateContent([
      prompt, 
      { inlineData: { data: base64Image, mimeType } }
    ]);
    
    const response = await result.response;
    const jsonString = response.text().match(/\{[\s\S]*\}/)?.[0] || "{}";
    const resultJson = JSON.parse(jsonString);

    // 3. NGだった場合の処理
    if (resultJson.isSafe === false) {
      const penaltyResult = await addViolation(supabase, userId, status.profile);
      
      let warningMsg = `理由: ${resultJson.reason}`;

      if (penaltyResult.isBanned) {
         warningMsg = "違反が重なったため、アカウントが永久停止されました。";
      } else if (penaltyResult.isSuspended) {
         warningMsg = "短時間に違反が集中したため、24時間の利用制限がかかりました。";
      } else {
         const remaining = VIOLATION_LIMIT - penaltyResult.newViolationCount;
         warningMsg += `\n\n⚠️ あと ${remaining} 回 違反すると、24時間の利用制限がかかります。`;
      }

      return { isSafe: false, reason: warningMsg };
    }

    return { isSafe: resultJson.isSafe ?? false, reason: resultJson.reason || "判定不能" };

  } catch (error) {
    console.error("Image Check Error:", error);
    return { isSafe: false, reason: "画像解析エラー" };
  }
}

// アクション実行前のチェック用（AI判定なし、ステータス確認のみ）
export async function checkUserRestriction(userId: string) {
  const supabase = getAdminSupabase();
  
  // 既存の判定ロジックを再利用
  const status = await checkAndPenaltyUser(supabase, userId);
  
  if (!status.allowed) {
    return { allowed: false, reason: status.msg }; // status.msg には「解除まであと◯時間」などが入っています
  }

  return { allowed: true, reason: "" };
}


----------------------------------------
### FILE: route.ts ###
----------------------------------------
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

export const dynamic = "force-dynamic"; // 常に最新データを取得

export async function GET() {
  // サーバー側でSupabaseクライアント作成
  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY! // 管理者キーを使う（確実に数えるため）
  );

  // 1. ログインユーザーのIDを取得（Cookieからじゃなくヘッダー等で本当はやるべきですが、簡易的にClientから送るか、ここでは簡略化のため固定ユーザーの確認ロジックにします）
  // ※本来は cookies() を使ってサーバー側でユーザー特定すべきですが、
  // 今回は「Service Role」を使わず、クライアントから渡されたアクセストークンを使うのが安全です。
  // ですが、一番簡単な「クライアント側で直接DBを見る」方法（ステップ3）で行きましょう！
  
  // APIルートを使わず、直接コンポーネントからSupabaseを叩くほうが今回は簡単なので、
  // このファイルは一旦「なし」でOKです！
  return NextResponse.json({ message: "Use client side fetching for simplicity" });
}


----------------------------------------
### FILE: route.ts ###
----------------------------------------
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import { GoogleGenerativeAI } from "@google/generative-ai";

// ★ここには何も書かないでください！ (変数の初期化は関数の中でやります)

export async function POST(request: Request) {
  try {
    // 1. クライアントの作成 (リクエストが来たタイミングで作る)
    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!
    );
    const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY!);

    const body = await request.json();
    const { user_id, category, content, page_url } = body;

    console.log("AI判定を開始します: ", content);

    // 2. AIによるモデレーション
    let status = "open"; 
    
    try {
      const model = genAI.getGenerativeModel({ model: "gemini-pro" });
      
      const prompt = `
        あなたはWebサービスの厳格なコンテンツモデレーターです。
        以下のフィードバック内容を分析し、少しでも「悪意」「嘲笑」「攻撃性」「不快感」が含まれる場合は有害と判定してください。

        【判定基準】
        - 誹謗中傷、暴言、脅迫は即アウト
        - 「馬鹿」「ゴミ」「くだらない」などの侮辱的な言葉が含まれる場合はアウト
        - 文末の「wwww」や「？？？？」など、相手を煽るような表現もアウト
        - 建設的な批判ではなく、単に相手を傷つける目的の文章はアウト

        回答は以下のJSON形式のみで返してください。
        { "is_harmful": true または false, "reason": "判定理由" }

        分析対象のテキスト:
        ${content}
      `;

      const result = await model.generateContent(prompt);
      const response = await result.response;
      const text = response.text();
      
      console.log("AIの回答 raw:", text);

      const jsonStr = text.replace(/```json|```/g, "").trim();
      const analysis = JSON.parse(jsonStr);

      if (analysis.is_harmful) {
        status = "attention";
        console.log("→ 有害判定されました:", analysis.reason);
      } else {
        console.log("→ 安全判定されました");
      }

    } catch (e) {
      console.error("!! AI判定中にエラーが発生しました !!");
      console.error(e);
    }

    // 3. Supabaseに保存
    const { error } = await supabase
      .from("feedbacks")
      .insert({
        user_id,
        category,
        content,
        page_url,
        status: status
      });

    if (error) throw error;

    return NextResponse.json({ success: true });

  } catch (error) {
    console.error("Feedback API Error:", error);
    return NextResponse.json({ error: "Failed to send feedback" }, { status: 500 });
  }
}


----------------------------------------
### FILE: route.ts ###
----------------------------------------
import { NextResponse } from "next/server";
import { S3Client, PutObjectCommand } from "@aws-sdk/client-s3";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";

// R2クライアントの作成
const R2 = new S3Client({
  region: "auto",
  endpoint: `https://${process.env.R2_ACCOUNT_ID}.r2.cloudflarestorage.com`,
  credentials: {
    accessKeyId: process.env.R2_ACCESS_KEY_ID!,
    secretAccessKey: process.env.R2_SECRET_ACCESS_KEY!,
  },
});

// ★重要: ここは "export default" ではなく "export async function POST" です！
export async function POST(request: Request) {
  try {
    const { fileType } = await request.json();
    
    // ユニークなファイル名を生成
    // もし uuid のインポートでエラーが出るなら、下の行を `${crypto.randomUUID()}.${...}` に変えてください
    const fileName = `${crypto.randomUUID()}.${fileType.split("/")[1]}`;

    // 「ここにアップロードしていいよ」という命令書を作成
    const putCommand = new PutObjectCommand({
      Bucket: process.env.R2_BUCKET_NAME,
      Key: fileName,
      ContentType: fileType,
    });

    // 署名付きURLを発行 (有効期限: 60秒)
    const signedUrl = await getSignedUrl(R2, putCommand, { expiresIn: 60 });

    // 公開用URL (DB保存用)
    const publicUrl = `${process.env.R2_PUBLIC_URL}/${fileName}`;

    return NextResponse.json({ signedUrl, publicUrl });
  } catch (error) {
    console.error("Upload API Error:", error);
    return NextResponse.json({ error: "Upload preparation failed" }, { status: 500 });
  }
}


----------------------------------------
### FILE: page.tsx ###
----------------------------------------
"use client";

import Link from "next/link";
import Image from "next/image";

export default function AuthErrorPage() {
  return (
    <div className="error-container">
      <h1 className="error-title">認証エラーが発生しました</h1>
      
      {/* アニメーションクラス(fade-in)をここにつける */}
      <div className="image-wrapper fade-in">
        <Image
          src="/images/sorry.png"
          alt="ごめんなさい"
          width={250}
          height={250}
          className="soft-circle-image"
          priority
        />
      </div>

      <p className="error-text">
        ログインやパスワードリセットの処理中に問題が発生しました。<br/>
        リンクの有効期限が切れている可能性があります。
      </p>
      
      <Link href="/login" className="btn btn-primary" style={{ padding: "12px 32px" }}>
        ログイン画面に戻る
      </Link>
    </div>
  );
}


----------------------------------------
### FILE: route.ts ###
----------------------------------------
import { createServerClient, type CookieOptions } from "@supabase/ssr";
import { cookies } from "next/headers";
import { NextResponse } from "next/server";

export async function GET(request: Request) {
  const { searchParams, origin } = new URL(request.url);
  const code = searchParams.get("code");
  // "next" パラメータがあればそこへ、なければダッシュボードへ
  const next = searchParams.get("next") ?? "/dashboard";

  if (code) {
    const cookieStore = await cookies();
    const supabase = createServerClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
      {
        cookies: {
          get(name: string) {
            return cookieStore.get(name)?.value;
          },
          set(name: string, value: string, options: CookieOptions) {
            cookieStore.set({ name, value, ...options });
          },
          remove(name: string, options: CookieOptions) {
            cookieStore.delete({ name, ...options });
          },
        },
      }
    );
    
    // コードを使ってセッションを確立
    const { error } = await supabase.auth.exchangeCodeForSession(code);
    
    if (!error) {
      return NextResponse.redirect(`${origin}${next}`);
    }
  }

  // エラーならエラー画面などへ（ここではとりあえずトップへ）
  return NextResponse.redirect(`${origin}/auth/auth-code-error`);
}

//更新用


----------------------------------------
### FILE: page.tsx ###
----------------------------------------


----------------------------------------
### FILE: page.tsx ###
----------------------------------------
"use client";

import { useEffect, useState } from "react";
import { supabase } from "@/lib/supabase";
import Link from "next/link";
import { ROLE_OPTIONS } from "@/lib/constants";

const PLAY_STYLE_OPTIONS = [
  "デスクトップモード",
  "VR (3点トラッキング)",
  "VR (フルトラッキング)",
  "スタンドアロン (Quest/Pico単体)",
  "その他 / 移行中",
];

const ITEMS_PER_PAGE = 24;

export default function CastListPage() {
  const [casts, setCasts] = useState<any[]>([]);
  const [loading, setLoading] = useState(true);

  const [viewMode, setViewMode] = useState<"grid" | "list" | "compact">("grid");
  const [sortBy, setSortBy] = useState<"newest" | "likes">("newest");

  const [filterRole, setFilterRole] = useState<string | null>(null);
  const [filterPlayStyle, setFilterPlayStyle] = useState<string | null>(null);
  const [searchName, setSearchName] = useState<string>("");

  const [currentPage, setCurrentPage] = useState(1);

  const getRoleLabel = (value: string | null) => {
    if (!value) return null;
    const found = ROLE_OPTIONS.find((opt) => opt.value === value);
    return found ? found.label : value;
  };

  // ★追加: 新着ユーザーかどうか判定する関数 (7日以内)
  const isNewMember = (createdAt: string) => {
    const diff = new Date().getTime() - new Date(createdAt).getTime();
    const days = diff / (1000 * 60 * 60 * 24);
    return days < 7;
  };

  useEffect(() => {
    const fetchCasts = async () => {
      const { data, error } = await supabase
        .from("profiles")
        .select("*, profile_likes!target_cast_id(count)")
        .order("created_at", { ascending: false });

      if (error) {
        console.error(error);
      } else {
        const formattedCasts = (data || []).map((cast: any) => ({
          ...cast,
          likesCount: cast.profile_likes ? cast.profile_likes[0]?.count || 0 : 0
        }));
        setCasts(formattedCasts);
      }
      setLoading(false);
    };

    fetchCasts();
  }, []);

  useEffect(() => {
    setCurrentPage(1);
  }, [filterRole, filterPlayStyle, searchName, sortBy]);

  const filteredCasts = casts.filter((cast) => {
    if (filterRole) {
      const hitMain = cast.role === filterRole;
      const hitSub1 = cast.sub_role_1 === filterRole;
      const hitSub2 = cast.sub_role_2 === filterRole;
      if (!hitMain && !hitSub1 && !hitSub2) return false;
    }
    if (filterPlayStyle && cast.play_style !== filterPlayStyle) return false;
    if (searchName && (!cast.display_name || !cast.display_name.toLowerCase().includes(searchName.toLowerCase()))) return false;
    return true;
  });

  const sortedCasts = [...filteredCasts].sort((a, b) => {
    if (filterRole) {
      const getPriority = (cast: any) => {
        if (cast.role === filterRole) return 2;
        return 1;
      };
      const priorityA = getPriority(a);
      const priorityB = getPriority(b);
      if (priorityA !== priorityB) {
        return priorityB - priorityA;
      }
    }
    if (sortBy === "newest") return b.created_at.localeCompare(a.created_at);
    if (sortBy === "likes") return b.likesCount - a.likesCount;
    return 0;
  });

  const totalItems = sortedCasts.length;
  const totalPages = Math.ceil(totalItems / ITEMS_PER_PAGE);
  
  const currentCasts = sortedCasts.slice(
    (currentPage - 1) * ITEMS_PER_PAGE,
    currentPage * ITEMS_PER_PAGE
  );

  const clearFilters = () => {
    setFilterRole(null);
    setFilterPlayStyle(null);
    setSearchName("");
  };

  const goToPage = (page: number) => {
    setCurrentPage(page);
    window.scrollTo({ top: 0, behavior: 'smooth' });
  };

  return (
    <>
      <header className="site-header">
        <div className="container header-inner">
          <Link href="/" className="logo-wrap" style={{ textDecoration: 'none' }}>
            <div className="logo-mark">C</div>
            <div className="logo-text-block">
              <div className="logo-text-main">Castket</div>
              <div className="logo-text-sub">Cast List</div>
            </div>
          </Link>
          <div className="header-actions">
            {/* ★修正: マイページへ → ダッシュボードへ */}
            <Link href="/dashboard" className="btn btn-ghost">ダッシュボードへ</Link>
          </div>
        </div>
      </header>

      <main className="section section-soft" style={{ minHeight: "100vh" }}>
        <div className="container">
          
          <div style={{ marginBottom: "24px" }}>
            <h1 className="section-title" style={{ margin: "0 0 16px 0", textAlign: "left" }}>キャストを探す</h1>

            {/* 絞り込みエリア */}
            <div className="filter-box" style={{ background: "#fff", padding: "16px", borderRadius: "12px", border: "1px solid #eee", marginBottom: "24px" }}>
              <div style={{ fontSize: "0.9rem", fontWeight: "bold", marginBottom: "12px", color: "#333", display: "flex", justifyContent: "space-between", alignItems: "center" }}>
                <span>🔍 条件で絞り込む</span>
                {(filterRole || filterPlayStyle || searchName) && (
                  <button onClick={clearFilters} style={{ background: "none", border: "none", color: "#ff4757", cursor: "pointer", fontSize: "0.85rem", textDecoration: "underline" }}>
                    × 条件をクリア
                  </button>
                )}
              </div>
              
              <div style={{ display: "flex", flexDirection: "column", gap: "12px" }}>
                <div className="filter-row">
                  <span className="filter-label" style={{ alignSelf: "center" }}>検索:</span>
                  <input type="text" placeholder="名前で検索..." value={searchName} onChange={(e) => setSearchName(e.target.value)} className="input-search"/>
                </div>
                <div className="filter-row">
                  <span className="filter-label">ロール:</span>
                  <div className="filter-options">
                    {ROLE_OPTIONS.map((option) => (
                      <button key={option.value} className={`filter-chip ${filterRole === option.value ? "active" : ""}`} onClick={() => setFilterRole(filterRole === option.value ? null : option.value)}>
                        {option.label}
                      </button>
                    ))}
                  </div>
                </div>
                <div className="filter-row">
                  <span className="filter-label">環境:</span>
                  <div className="filter-options">
                    {PLAY_STYLE_OPTIONS.map((style) => (
                      <button key={style} className={`filter-chip ${filterPlayStyle === style ? "active" : ""}`} onClick={() => setFilterPlayStyle(filterPlayStyle === style ? null : style)}>
                        {style}
                      </button>
                    ))}
                  </div>
                </div>
              </div>
            </div>
            
            <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", flexWrap: "wrap", gap: "16px" }}>
              <p style={{ margin: 0, color: "#666", fontSize: "0.9rem" }}>
                <b>{totalItems}</b> 名ヒット 
                {totalPages > 1 && ` (ページ ${currentPage} / ${totalPages})`}
              </p>
              <div style={{ display: "flex", alignItems: "center", gap: "16px", flexWrap: "wrap" }}>
                <select value={sortBy} onChange={(e) => setSortBy(e.target.value as any)} className="sort-select">
                  <option value="newest">🆕 新着順</option>
                  <option value="likes">💖 人気順</option>
                </select>
                <div className="view-toggle-area" style={{ margin: 0 }}>
                  <button className={`view-btn ${viewMode === "grid" ? "active" : ""}`} onClick={() => setViewMode("grid")} title="グリッド">田</button>
                  <button className={`view-btn ${viewMode === "list" ? "active" : ""}`} onClick={() => setViewMode("list")} title="リスト">☰</button>
                  <button className={`view-btn ${viewMode === "compact" ? "active" : ""}`} onClick={() => setViewMode("compact")} title="テキスト">≣</button>
                </div>
              </div>
            </div>
          </div>
          
          {/* ▼▼▼ ローディング中は「スケルトン」を表示する処理に変更 ▼▼▼ */}
          {loading ? (
             <div style={{ display: "grid", gap: "16px", gridTemplateColumns: "repeat(auto-fill, minmax(180px, 1fr))" }}>
                {/* 12個くらいダミーの箱を表示しておく */}
                {[...Array(12)].map((_, i) => (
                  <div key={i} className="card skeleton-card" style={{ height: "280px", padding: 0 }}>
                    <div className="skeleton-image"></div>
                    <div style={{ padding: "12px" }}>
                      <div className="skeleton-text" style={{ width: "60%" }}></div>
                      <div className="skeleton-text" style={{ width: "40%", marginTop: "8px" }}></div>
                    </div>
                  </div>
                ))}
             </div>
          ) : currentCasts.length === 0 ? (
            <div className="card" style={{ textAlign: "center", padding: "60px" }}>
              <p>条件に一致するキャストは見つかりませんでした。</p>
              <button onClick={clearFilters} className="btn btn-ghost" style={{ marginTop: "16px" }}>条件をリセットする</button>
            </div>
          ) : (
            <>
              <div 
                className={`event-grid event-container ${viewMode === "list" ? "list-view" : ""} ${viewMode === "compact" ? "compact-view" : ""}`} 
                style={{ 
                  display: "grid", 
                  gap: "16px",
                  gridTemplateColumns: viewMode === "grid" ? "repeat(auto-fill, minmax(180px, 1fr))" : undefined,
                  marginBottom: "40px"
                }}
              >
                {currentCasts.map((cast) => {
                  const isMainHit = filterRole && cast.role === filterRole;
                  const isSubHit1 = filterRole && cast.sub_role_1 === filterRole;
                  const isSubHit2 = filterRole && cast.sub_role_2 === filterRole;
                  // ★追加: 新着判定
                  const isNew = isNewMember(cast.created_at);

                  return (
                    <Link href={`/casts/${cast.user_id}`} key={cast.id} style={{ textDecoration: "none", color: "inherit" }}>
                      <div 
                        className={`card hover-up event-card ${viewMode === "list" ? "list-view" : ""} ${viewMode === "compact" ? "compact-view" : ""}`} 
                        style={{ 
                          padding: "0", 
                          overflow: "hidden", 
                          display: "flex", 
                          flexDirection: "column", 
                          height: "100%",
                          borderRadius: "8px",
                          border: "1px solid #eaeaea",
                        }}
                      >
                        {viewMode !== "compact" && (
                          <div className="card-image" style={{ width: "100%", aspectRatio: "1/1", background: "#f9f9f9", position: "relative", borderBottom: "1px solid #f0f0f0" }}>
                            
                            {/* ロールバッジ */}
                            {cast.role && (
                               <div style={{ position: "absolute", top: "4px", left: "4px", zIndex: 2 }}>
                                 <span style={{ 
                                   background: isMainHit ? "#ff4757" : "rgba(124, 58, 237, 0.9)",
                                   color: "#fff", padding: "2px 6px", borderRadius: "4px", fontSize: "0.65rem", fontWeight: "bold" 
                                 }}>
                                   {getRoleLabel(cast.role)}
                                 </span>
                               </div>
                            )}

                            {/* ★追加: NEWバッジ (右上に表示) */}
                            {isNew && (
                               <div style={{ position: "absolute", top: "4px", right: "4px", zIndex: 2 }}>
                                 <span className="new-badge">🔰 NEW</span>
                               </div>
                            )}

                            {cast.avatar_url ? (
                              // eslint-disable-next-line @next/next/no-img-element
                              <img src={cast.avatar_url} alt={cast.display_name} style={{ width: "100%", height: "100%", objectFit: "cover" }} />
                            ) : (
                              <div style={{ width: "100%", height: "100%", display: "flex", alignItems: "center", justifyContent: "center", color: "#ccc", fontSize: "2rem" }}>👤</div>
                            )}
                          </div>
                        )}

                        <div style={{ padding: "12px", flex: 1, display: "flex", flexDirection: "column", width: "100%" }}>
                          <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: "4px" }}>
                            <h3 style={{ fontSize: "1rem", fontWeight: "bold", margin: 0, lineHeight: 1.3, overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap", flex: 1 }}>
                              {cast.display_name || "ゲスト"}
                            </h3>
                            {cast.likesCount > 0 && (
                              <div style={{ fontSize: "0.75rem", color: "#ff4757", fontWeight: "bold", display: "flex", alignItems: "center", gap: "2px", marginLeft: "4px" }}>
                                <span>♥</span>{cast.likesCount}
                              </div>
                            )}
                          </div>

                          {(cast.sub_role_1 || cast.sub_role_2) && (
                            <div style={{ display: "flex", gap: "4px", flexWrap: "wrap", marginBottom: "8px" }}>
                              {cast.sub_role_1 && (
                                <span className="sub-role-badge" style={isSubHit1 ? { background: "#ffe4e6", color: "#be123c", borderColor: "#fda4af" } : {}}>{getRoleLabel(cast.sub_role_1)}</span>
                              )}
                              {cast.sub_role_2 && (
                                <span className="sub-role-badge" style={isSubHit2 ? { background: "#ffe4e6", color: "#be123c", borderColor: "#fda4af" } : {}}>{getRoleLabel(cast.sub_role_2)}</span>
                              )}
                            </div>
                          )}
                          
                          {viewMode !== "compact" && (
                            <div className="card-desc" style={{ 
                              fontSize: "0.8rem", 
                              color: "#666", 
                              marginTop: "auto", 
                              display: "-webkit-box", 
                              WebkitLineClamp: 5, 
                              WebkitBoxOrient: "vertical", 
                              overflow: "hidden",
                              lineHeight: "1.5"
                            }}>
                              {cast.bio || "自己紹介文はまだありません。"}
                            </div>
                          )}
                          {viewMode === "compact" && (
                            <div style={{ fontSize: "0.8rem", color: "var(--accent)" }}>{getRoleLabel(cast.role)}</div>
                          )}
                        </div>
                      </div>
                    </Link>
                  );
                })}
              </div>

              {totalPages > 1 && (
                <div style={{ display: "flex", justifyContent: "center", alignItems: "center", gap: "16px", marginTop: "24px" }}>
                  <button onClick={() => goToPage(currentPage - 1)} disabled={currentPage === 1} className="pagination-btn">
                    &lt; 前へ
                  </button>
                  <span style={{ fontWeight: "bold", color: "#555" }}>
                    {currentPage} / {totalPages}
                  </span>
                  <button onClick={() => goToPage(currentPage + 1)} disabled={currentPage === totalPages} className="pagination-btn">
                    次へ &gt;
                  </button>
                </div>
              )}
            </>
          )}
        </div>
      </main>

      <style jsx>{`
        /* スケルトンローディングのアニメーション */
        @keyframes shimmer {
          0% { background-position: -200% 0; }
          100% { background-position: 200% 0; }
        }
        .skeleton-card {
          border: 1px solid #eee;
          background: #fff;
          overflow: hidden;
        }
        .skeleton-image {
          width: 100%;
          aspect-ratio: 1/1;
          background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
          background-size: 200% 100%;
          animation: shimmer 1.5s infinite;
        }
        .skeleton-text {
          height: 12px;
          background: #eee;
          border-radius: 4px;
        }

        /* NEWバッジ */
        .new-badge {
            background: #22c55e;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.65rem;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .pagination-btn {
          padding: 8px 16px;
          border: 1px solid #ddd;
          background: #fff;
          border-radius: 8px;
          cursor: pointer;
          font-weight: bold;
          color: #555;
          transition: all 0.2s;
        }
        .pagination-btn:hover:not(:disabled) {
          background: var(--accent);
          color: #fff;
          border-color: var(--accent);
        }
        .pagination-btn:disabled {
          opacity: 0.5;
          cursor: not-allowed;
          background: #f5f5f5;
        }

        .input-search { padding: 8px 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 0.95rem; width: 100%; max-width: 300px; }
        .input-search:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 3px rgba(124, 58, 237, 0.1); }
        .sub-role-badge { background: #f0f0f0; color: #666; font-size: 0.65rem; padding: 2px 6px; borderRadius: 3px; border: 1px solid #eee; white-space: nowrap; }
        .filter-row { display: flex; align-items: flex-start; gap: 16px; }
        .filter-label { font-weight: bold; font-size: 0.85rem; color: #666; width: 50px; padding-top: 6px; flex-shrink: 0; }
        .filter-options { display: flex; flex-wrap: wrap; gap: 6px; flex: 1; }
        .filter-chip { background: #f5f5f5; border: 1px solid #ddd; padding: 4px 10px; border-radius: 99px; cursor: pointer; font-size: 0.8rem; color: #555; transition: all 0.2s; }
        .filter-chip:hover { background: #eaeaea; }
        .filter-chip.active { background: var(--accent); color: #fff; border-color: var(--accent); }
        .sort-select { padding: 6px 10px; border-radius: 6px; border: 1px solid #ddd; background: #fff; font-size: 0.85rem; cursor: pointer; outline: none; }
        .hover-up { transition: transform 0.2s, box-shadow 0.2s; }
        .hover-up:hover { transform: translateY(-3px); box-shadow: 0 6px 12px rgba(0,0,0,0.08); }
        @media (max-width: 600px) { .filter-row { flex-direction: column; gap: 8px; } .filter-label { width: auto; padding-top: 0; } }
      `}</style>
    </>
  );
}


----------------------------------------
### FILE: page.tsx ###
----------------------------------------


----------------------------------------
### FILE: page.tsx ###
----------------------------------------
"use client";

import { useEffect, useState } from "react";
import { supabase } from "@/lib/supabase";
import Link from "next/link";
import { useRouter } from "next/navigation";
import EventBannerUpload from "@/components/EventBannerUpload";
import { EVENT_TAGS } from "@/lib/constants";
import { checkContentSafety, checkImageSafety } from "@/app/actions/moderate";
import toast from "react-hot-toast";

const WEEKDAYS = [
  { val: "Sun", label: "日" },
  { val: "Mon", label: "月" },
  { val: "Tue", label: "火" },
  { val: "Wed", label: "水" },
  { val: "Thu", label: "木" },
  { val: "Fri", label: "金" },
  { val: "Sat", label: "土" },
];

export default function MyEventsPage() {
  const router = useRouter();
  const [loading, setLoading] = useState(true);
  const [user, setUser] = useState<any>(null);
  const [myEvents, setMyEvents] = useState<any[]>([]);

  // ★追加: 編集モードかどうかの判定用ID (nullなら新規作成)
  const [editingEventId, setEditingEventId] = useState<string | null>(null);

  // フォーム入力用
  const [title, setTitle] = useState("");
  const [description, setDescription] = useState("");
  const [requirements, setRequirements] = useState("");
  const [bannerUrl, setBannerUrl] = useState("");
  const [selectedTags, setSelectedTags] = useState<string[]>([]);
  const [privateInfo, setPrivateInfo] = useState("");
  const [capacity, setCapacity] = useState(""); 

  const [isSubmitting, setIsSubmitting] = useState(false);

  // 日時・スケジュール設定用
  const [scheduleType, setScheduleType] = useState("one_time");
  const [startTime, setStartTime] = useState("");
  const [endTime, setEndTime] = useState("");
  const [singleDate, setSingleDate] = useState("");
  const [selectedWeekdays, setSelectedWeekdays] = useState<string[]>([]);
  const [irregularDatesText, setIrregularDatesText] = useState("");

  // ★追加: 今日の日付を取得 (YYYY-MM-DD形式)
  const todayStr = new Date().toISOString().split('T')[0];

  useEffect(() => {
    const fetchData = async () => {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        router.push("/login");
        return;
      }
      setUser(user);
      fetchMyEvents(user.id); // 再利用できるように関数化
    };
    fetchData();
  }, [router]);

  // イベント一覧取得関数
  const fetchMyEvents = async (userId: string) => {
    const { data } = await supabase
      .from("events")
      .select("*")
      .eq("organizer_id", userId)
      .order("created_at", { ascending: false });
    if (data) setMyEvents(data);
    setLoading(false);
  };

  // ★追加: フォームをリセットする関数
  const resetForm = () => {
    setEditingEventId(null);
    setTitle("");
    setDescription("");
    setRequirements("");
    setBannerUrl("");
    setSelectedTags([]);
    setPrivateInfo("");
    setCapacity("");
    setScheduleType("one_time");
    setStartTime("");
    setEndTime("");
    setSingleDate("");
    setSelectedWeekdays([]);
    setIrregularDatesText("");
    setIsSubmitting(false);
  };

  // ★追加: 編集ボタンを押したときの処理
  const handleEditClick = (event: any) => {
    setEditingEventId(event.id);
    setTitle(event.title);
    setDescription(event.description || "");
    setRequirements(event.requirements || "");
    setBannerUrl(event.banner_url || "");
    setSelectedTags(event.tags || []);
    setPrivateInfo(event.private_info || "");
    setCapacity(event.capacity ? event.capacity.toString() : "");
    
    setScheduleType(event.schedule_type);
    setStartTime(event.start_time || "");
    setEndTime(event.end_time || "");
    
    if (event.schedule_type === "one_time") {
      setSingleDate(event.event_date || "");
    }
    if (event.schedule_type === "weekly") {
      setSelectedWeekdays(event.weekdays || []);
    }
    if (event.schedule_type === "irregular") {
      setIrregularDatesText(event.irregular_dates ? event.irregular_dates.join("\n") : "");
    }

    // フォームまでスクロール
    window.scrollTo({ top: 0, behavior: "smooth" });
  };

  const handleTagChange = (tag: string) => {
    if (selectedTags.includes(tag)) {
      setSelectedTags(selectedTags.filter(t => t !== tag));
    } else {
      setSelectedTags([...selectedTags, tag]);
    }
  };

  const handleWeekdayChange = (day: string) => {
    if (selectedWeekdays.includes(day)) {
      setSelectedWeekdays(selectedWeekdays.filter(d => d !== day));
    } else {
      setSelectedWeekdays([...selectedWeekdays, day]);
    }
  };

  // 作成・更新処理
  const handleSaveEvent = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!user) return;
    setIsSubmitting(true);

    try {
      // ▼▼▼ AIチェック ▼▼▼
      const contentToCheck = `タイトル: ${title}\n詳細: ${description}\n要項: ${requirements}`;
      const textCheckResult = await checkContentSafety(contentToCheck, user.id);

      if (!textCheckResult.isSafe) {
        toast.error(`登録エラー: ${textCheckResult.reason}`, {
          duration: 5000, // 5秒間表示
        });
        setIsSubmitting(false);
        return; 
      }

      if (bannerUrl) {
        // ※編集時、画像URLが変わっていない場合はチェックをスキップしても良いですが、
        // 今回はシンプルに毎回チェック、または以前のURLと同じならスキップなどの判定も可能です。
        const imageCheckResult = await checkImageSafety(bannerUrl, user.id);
        if (!imageCheckResult.isSafe) {
toast.error(`登録エラー:${imageCheckResult.reason}`, {
    duration: 5000, // 5秒間表示
  });
          setIsSubmitting(false);
          return; 
        }
      }
      // ▲▲▲ AIチェック終了 ▲▲▲

      let irregularDatesArray: string[] = [];
      if (scheduleType === "irregular") {
        irregularDatesArray = irregularDatesText
          .split(/,|\n/)
          .map(d => d.trim())
          .filter(d => d !== "");
      }

      const eventData = {
        organizer_id: user.id,
        title: title,
        description: description,
        requirements: requirements,
        banner_url: bannerUrl,
        tags: selectedTags,
        private_info: privateInfo,
        capacity: capacity ? parseInt(capacity) : null,
        schedule_type: scheduleType,
        start_time: startTime || null,
        end_time: endTime || null,
        event_date: scheduleType === "one_time" ? singleDate : null,
        weekdays: scheduleType === "weekly" ? selectedWeekdays : null,
        irregular_dates: scheduleType === "irregular" ? irregularDatesArray : null,
      };

      if (editingEventId) {
        // ★更新処理 (UPDATE)
        const { error } = await supabase
          .from("events")
          .update(eventData)
          .eq("id", editingEventId);

        if (error) throw error;
        toast.success("イベントを更新しました！");
      } else {
        // ★新規作成処理 (INSERT)
        const { error } = await supabase
          .from("events")
          .insert(eventData);

        if (error) throw error;
        toast.success("イベントを作成しました！");
      }

      // リロードせずにデータを再取得してフォームをクリア
      await fetchMyEvents(user.id);
      resetForm();

    } catch (error: any) {
      toast.error("エラー: " + error.message);
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleDelete = async (id: string) => {
    if (!confirm("本当にこのイベントを削除しますか？")) return;
    const { error } = await supabase.from("events").delete().eq("id", id);
    if (!error) {
      setMyEvents(myEvents.filter((e) => e.id !== id));
      // もし編集中のイベントを削除したらフォームもリセット
      if (editingEventId === id) resetForm();
    }
  };

  return (
    <>
      <header className="site-header">
        <div className="container header-inner">
          <Link href="/dashboard" className="logo-wrap" style={{ textDecoration: 'none' }}>
            <div className="logo-mark">C</div>
            <div className="logo-text-block">
              <div className="logo-text-main">Castket</div>
              <div className="logo-text-sub">Event Manager</div>
            </div>
          </Link>
          <div className="header-actions">
            <Link href="/dashboard" className="btn btn-ghost">← ダッシュボードに戻る</Link>
          </div>
        </div>
      </header>

      <main className="section section-soft" style={{ minHeight: "100vh" }}>
        <div className="container">
          <h1 className="section-title" style={{ textAlign: "left", marginBottom: "32px" }}>イベント管理</h1>

          <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: "32px", alignItems: "start" }}>
            
            {/* 左側：入力フォーム */}
            <div className="card" style={{ border: editingEventId ? "2px solid var(--accent)" : "none" }}>
              <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
                <h2 className="card-title">
                  {editingEventId ? "イベントを編集" : "新規イベント作成"}
                </h2>
                {editingEventId && (
                  <button onClick={resetForm} style={{ fontSize: "0.85rem", color: "var(--muted)", background: "none", border: "none", cursor: "pointer", textDecoration: "underline" }}>
                    編集をキャンセル
                  </button>
                )}
              </div>

              <form onSubmit={handleSaveEvent} style={{ display: "grid", gap: "16px", marginTop: "16px" }}>
                
                <div>
                  <label className="label-bold">イベントバナー画像</label>
                  <EventBannerUpload 
                    userId={user?.id || ""}
                    url={bannerUrl}
                    onUpload={(url) => setBannerUrl(url)}
                  />
                </div>

                <div>
                  <label className="label-bold">イベント名</label>
                  <input
                    type="text"
                    required
                    value={title}
                    onChange={(e) => setTitle(e.target.value)}
                    placeholder="例: Bar Noxtella"
                    className="input-field"
                  />
                </div>

                <div>
                  <label className="label-bold">募集人数 (定員)</label>
                  <input
                    type="number"
                    min="1"
                    value={capacity}
                    onChange={(e) => setCapacity(e.target.value)}
                    placeholder="空欄の場合は「無制限」になります"
                    className="input-field"
                  />
                </div>

                <div>
                  <label className="label-bold">ジャンルタグ (複数選択可)</label>
                  <div style={{ display: "flex", flexWrap: "wrap", gap: "8px" }}>
                    {EVENT_TAGS.map((tag) => (
                      <label key={tag} style={{ 
                        padding: "6px 12px", 
                        borderRadius: "99px", 
                        border: "1px solid var(--border)",
                        fontSize: "0.85rem",
                        cursor: "pointer",
                        background: selectedTags.includes(tag) ? "var(--accent)" : "#fff",
                        color: selectedTags.includes(tag) ? "#fff" : "var(--text)",
                        transition: "all 0.2s"
                      }}>
                        <input 
                          type="checkbox" 
                          value={tag} 
                          checked={selectedTags.includes(tag)} 
                          onChange={() => handleTagChange(tag)}
                          style={{ display: "none" }} 
                        />
                        {tag}
                      </label>
                    ))}
                  </div>
                </div>

                <div style={{ background: "var(--bg)", padding: "16px", borderRadius: "8px" }}>
                  <label className="label-bold">開催スケジュール</label>
                  <div style={{ display: "flex", gap: "12px", marginBottom: "16px" }}>
                    <label style={{ display: "flex", alignItems: "center", gap: "4px", cursor: "pointer" }}><input type="radio" name="type" value="one_time" checked={scheduleType === "one_time"} onChange={(e) => setScheduleType(e.target.value)} /> 単発</label>
                    <label style={{ display: "flex", alignItems: "center", gap: "4px", cursor: "pointer" }}><input type="radio" name="type" value="weekly" checked={scheduleType === "weekly"} onChange={(e) => setScheduleType(e.target.value)} /> 毎週</label>
                    <label style={{ display: "flex", alignItems: "center", gap: "4px", cursor: "pointer" }}><input type="radio" name="type" value="irregular" checked={scheduleType === "irregular"} onChange={(e) => setScheduleType(e.target.value)} /> 不定期</label>
                  </div>
                  <div style={{ marginBottom: "16px" }}>
                    {scheduleType === "one_time" && (
                      // ★修正: min={todayStr} を追加して過去の日付を選べなくしました
                      <input 
                        type="date" 
                        className="input-field" 
                        required 
                        min={todayStr} 
                        value={singleDate} 
                        onChange={(e) => setSingleDate(e.target.value)} 
                      />
                    )}
                    {scheduleType === "weekly" && (
                      <div style={{ display: "flex", gap: "8px", flexWrap: "wrap" }}>
                        {WEEKDAYS.map(day => (
                          <label key={day.val} style={{ 
                            padding: "6px 12px", borderRadius: "4px", 
                            background: selectedWeekdays.includes(day.val) ? "var(--accent)" : "#fff",
                            color: selectedWeekdays.includes(day.val) ? "#fff" : "var(--text)",
                            border: "1px solid var(--border)", cursor: "pointer", fontSize: "0.9rem"
                          }}>
                            <input type="checkbox" value={day.val} checked={selectedWeekdays.includes(day.val)} onChange={() => handleWeekdayChange(day.val)} style={{ display: "none" }} />
                            {day.label}
                          </label>
                        ))}
                      </div>
                    )}
                    {scheduleType === "irregular" && (
                      <textarea className="input-field" rows={3} placeholder="例:&#13;2025-12-01&#13;2025-12-15" value={irregularDatesText} onChange={(e) => setIrregularDatesText(e.target.value)} />
                    )}
                  </div>
                  <div style={{ display: "flex", gap: "12px", alignItems: "center" }}>
                    <div style={{ flex: 1 }}><input type="time" className="input-field" value={startTime} onChange={(e) => setStartTime(e.target.value)} /></div>
                    <span>〜</span>
                    <div style={{ flex: 1 }}><input type="time" className="input-field" value={endTime} onChange={(e) => setEndTime(e.target.value)} /></div>
                  </div>
                </div>

                <div>
                  <label className="label-bold">イベント詳細 (一般公開用)</label>
                  <textarea required rows={5} value={description} onChange={(e) => setDescription(e.target.value)} placeholder="イベントの内容..." className="input-field" style={{ fontFamily: "inherit" }} />
                </div>

                <div>
                  <label className="label-bold">募集要項 (キャスト志望者向け)</label>
                  <textarea rows={5} value={requirements} onChange={(e) => setRequirements(e.target.value)} placeholder="求める人物像..." className="input-field" style={{ fontFamily: "inherit" }} />
                </div>

                <div style={{ background: "#fdfaff", padding: "16px", borderRadius: "8px", border: "2px dashed var(--accent)" }}>
                  <label className="label-bold" style={{ color: "var(--accent)" }}>🔒 参加者限定情報 (任意)</label>
                  <textarea
                    rows={3}
                    value={privateInfo}
                    onChange={(e) => setPrivateInfo(e.target.value)}
                    placeholder="DiscordのURLなど..."
                    className="input-field"
                    style={{ fontFamily: "inherit", background: "#fff" }}
                  />
                </div>

                <button type="submit" className="btn btn-primary" disabled={isSubmitting}>
                  {isSubmitting ? "処理中..." : (editingEventId ? "変更を保存する" : "イベントを作成する")}
                </button>
              </form>
            </div>

            {/* 右側：リスト表示 */}
            <div>
              <h2 className="section-lead" style={{ textAlign: "left", marginBottom: "16px" }}>登録済みイベント</h2>
              {myEvents.length === 0 ? (
                <p style={{ color: "var(--muted)" }}>まだ登録されたイベントはありません。</p>
              ) : (
                <div style={{ display: "grid", gap: "16px" }}>
                  {myEvents.map((event) => (
                    <div key={event.id} className="card" style={{ padding: "0", overflow: "hidden" }}>
                      
                      {/* ★追加: 画像とタイトル部分をクリックすると詳細ページへ飛ぶリンクを追加 */}
                      <Link href={`/events/${event.id}`} style={{ textDecoration: "none", color: "inherit", display: "block" }}>
                        {event.banner_url && (
                          <div style={{ width: "100%", aspectRatio: "16/9", background: "var(--bg)" }}>
                            {/* eslint-disable-next-line @next/next/no-img-element */}
                            <img src={event.banner_url} alt={event.title} style={{ width: "100%", height: "100%", objectFit: "cover" }} />
                          </div>
                        )}
                        <div style={{ padding: "20px 20px 10px 20px" }}>
                          <div style={{ display: "flex", gap: "6px", flexWrap: "wrap", marginBottom: "8px" }}>
                            {event.tags && event.tags.map((tag: string) => (
                              <span key={tag} style={{ fontSize: "0.75rem", padding: "2px 8px", background: "var(--bg)", borderRadius: "6px", color: "var(--text)" }}>#{tag}</span>
                            ))}
                          </div>
                          <div style={{ display: "flex", justifyContent: "space-between", alignItems: "start" }}>
                            <div>
                              <h3 style={{ fontSize: "1.2rem", fontWeight: "bold", marginBottom: "8px" }}>{event.title}</h3>
                              {event.capacity && (
                                <div style={{ fontSize: "0.85rem", color: "var(--accent)", fontWeight: "bold", marginBottom: "8px" }}>
                                  募集: {event.capacity}名
                                </div>
                              )}
                            </div>
                          </div>
                          <p style={{ fontSize: "0.9rem", color: "var(--muted)", whiteSpace: "pre-wrap" }}>
                            {event.description.length > 30 ? event.description.slice(0, 30) + "..." : event.description}
                          </p>
                        </div>
                      </Link>

                      {/* 操作ボタンエリア (リンクの外に出す) */}
                      <div style={{ padding: "0 20px 20px 20px", display: "flex", gap: "8px", justifyContent: "flex-end", borderTop: "1px solid #eee", paddingTop: "12px", marginTop: "4px" }}>
                        {/* ★追加: 編集ボタン */}
                        <button 
                          onClick={() => handleEditClick(event)} 
                          style={{ background: "#fff", border: "1px solid var(--accent)", color: "var(--accent)", padding: "6px 14px", borderRadius: "6px", cursor: "pointer", fontSize: "0.85rem", fontWeight: "bold" }}
                        >
                          ✎ 編集
                        </button>

                        <Link href={`/dashboard/events/${event.id}`}>
                          <button style={{ background: "var(--bg)", border: "1px solid var(--border)", padding: "6px 14px", borderRadius: "6px", cursor: "pointer", fontSize: "0.85rem" }}>👥 応募管理</button>
                        </Link>
                        
                        <button onClick={() => handleDelete(event.id)} style={{ background: "none", border: "none", color: "#ff4757", cursor: "pointer", fontSize: "0.85rem" }}>削除</button>
                      </div>

                    </div>
                  ))}
                </div>
              )}
            </div>

          </div>
        </div>
      </main>
      <style jsx>{`
        .label-bold { display: block; margin-bottom: 8px; fontWeight: bold; }
        .input-field { width: 100%; padding: 10px; border-radius: 8px; border: 1px solid var(--border); }
      `}</style>
    </>
  );
}


----------------------------------------
### FILE: page.tsx ###
----------------------------------------
"use client";

import { useEffect, useState, useRef } from "react";
import { supabase } from "@/lib/supabase";
import { useRouter } from "next/navigation";
import { checkUserRestriction } from "@/app/actions/moderate";
import { ROLE_OPTIONS } from "@/lib/constants";
import toast from "react-hot-toast";

const PLAY_STYLE_OPTIONS = [
  "デスクトップモード",
  "VR (3点トラッキング)",
  "VR (フルトラッキング)",
  "スタンドアロン (Quest/Pico単体)",
  "その他 / 移行中",
];

export default function EditProfilePage() {
  const router = useRouter();
  const [loading, setLoading] = useState(true);
  const [user, setUser] = useState<any>(null);
  
  // プロフィール更新用ステート
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isCompressing, setIsCompressing] = useState(false); // アバター圧縮中フラグ

  // 基本情報ステート
  const [displayName, setDisplayName] = useState("");
  const [role, setRole] = useState(ROLE_OPTIONS[0].value);
  const [subRole1, setSubRole1] = useState("");
  const [subRole2, setSubRole2] = useState("");
  const [playStyle, setPlayStyle] = useState("");
  const [bio, setBio] = useState("");
  
  // アバター関連
  const [previewUrl, setPreviewUrl] = useState(""); // 表示用URL
  const [avatarFile, setAvatarFile] = useState<File | null>(null); // アップロード待ちファイル
  const originalAvatarUrl = useRef<string>(""); // 元の画像URL（削除用）

  // ポートフォリオ（ギャラリー）関連ステート
  const [portfolioImages, setPortfolioImages] = useState<any[]>([]);
  const [isGalleryUploading, setIsGalleryUploading] = useState(false);

  useEffect(() => {
    const fetchData = async () => {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        router.push("/login");
        return;
      }
      setUser(user);

      // 1. プロフィール情報の取得
      const { data: profile } = await supabase
        .from("profiles")
        .select("*")
        .eq("user_id", user.id)
        .single();

      if (profile) {
        setDisplayName(profile.display_name || "");
        setRole(profile.role || ROLE_OPTIONS[0].value);
        setSubRole1(profile.sub_role_1 || "");
        setSubRole2(profile.sub_role_2 || "");
        setPlayStyle(profile.play_style || "");
        setBio(profile.bio || "");
        
        const currentUrl = profile.avatar_url || "";
        setPreviewUrl(currentUrl);
        originalAvatarUrl.current = currentUrl;
      }

      // 2. ポートフォリオ画像の取得
      const { data: images } = await supabase
        .from("portfolio_images")
        .select("*")
        .eq("user_id", user.id)
        .order("created_at", { ascending: true });

      if (images) {
        setPortfolioImages(images);
      }

      setLoading(false);
    };

    fetchData();
  }, [router]);

  // 画像削除APIを呼び出す関数
  const deleteImageFromR2 = async (url: string) => {
    if (!url) return;
    try {
      await fetch("/api/delete-image", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ fileUrl: url }),
      });
      console.log("削除リクエスト送信:", url);
    } catch (e) {
      console.error("古い画像の削除に失敗:", e);
    }
  };

  // R2アップロード処理（共通関数）
  const uploadImageToR2 = async (file: File) => {
    const res = await fetch("/api/upload", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ fileType: file.type }),
    });
    
    if (!res.ok) throw new Error("署名付きURLの取得に失敗しました");
    const { signedUrl, publicUrl } = await res.json();
  
    const uploadRes = await fetch(signedUrl, {
      method: "PUT",
      headers: { "Content-Type": file.type },
      body: file,
    });
  
    if (!uploadRes.ok) throw new Error("アップロードに失敗しました");
  
    return publicUrl;
  };

  // アバター: ファイルを選択しただけ（プレビュー表示のみ、アップロードはまだ）
  const handleFileSelect = async (e: React.ChangeEvent<HTMLInputElement>) => {
    if (!e.target.files || e.target.files.length === 0) return;
    
    const file = e.target.files[0];
    setIsCompressing(true);

    try {
      // ★修正: 自作のユーティリティを動的インポート
      const { compressImage } = await import("@/app/utils/imageCompressor");

      // アバター用に圧縮
      const compressedFile = await compressImage(file, "avatar");

      setAvatarFile(compressedFile);
      const localUrl = URL.createObjectURL(compressedFile);
      setPreviewUrl(localUrl);

    } catch (error) {
      console.error(error);
      toast.error("画像の読み込みに失敗しました");
    } finally {
      setIsCompressing(false);
    }
  };

  // ギャラリー画像のアップロード（選択即アップロード）
  const handleGalleryUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    if (!e.target.files || e.target.files.length === 0) return;
    if (portfolioImages.length >= 4) {
      toast.error("画像は最大4枚までです");
      return;
    }
    
    setIsGalleryUploading(true);
    const file = e.target.files[0];
    
    try {
      // ★修正: 自作のユーティリティを動的インポート
      const { compressImage } = await import("@/app/utils/imageCompressor");

      // ギャラリー用に圧縮
      const compressedFile = await compressImage(file, "gallery");
      
      const publicUrl = await uploadImageToR2(compressedFile);
  
      // DBに保存
      const { data, error } = await supabase
        .from("portfolio_images")
        .insert({
          user_id: user.id,
          image_url: publicUrl
        })
        .select()
        .single();
  
      if (error) throw error;
  
      // 画面に即反映
      setPortfolioImages([...portfolioImages, data]);
  
    } catch (error: any) {
      console.error(error);
      toast.error("アップロード失敗: " + error.message);
    } finally {
      setIsGalleryUploading(false);
    }
  };
  
  // ギャラリー画像の削除
  const handleDeleteGalleryImage = async (imageId: string, imageUrl: string) => {
    if (!confirm("この画像を削除しますか？")) return;
  
    try {
      // 1. DBから削除
      const { error } = await supabase
        .from("portfolio_images")
        .delete()
        .eq("id", imageId);
  
      if (error) throw error;
  
      // 2. R2から削除
      await deleteImageFromR2(imageUrl);
  
      // 3. 画面から削除
      setPortfolioImages(portfolioImages.filter(img => img.id !== imageId));
  
    } catch (error: any) {
      toast.error("削除失敗: " + error.message);
    }
  };

  // プロフィール全体の保存処理
  const handleUpdate = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!user) return;
    setIsSubmitting(true);

    try {
      const restriction = await checkUserRestriction(user.id);
      if (!restriction.allowed) throw new Error(restriction.reason);

      let finalAvatarUrl = previewUrl;

      // 新しいアバターファイルがあればアップロード
      if (avatarFile) {
        finalAvatarUrl = await uploadImageToR2(avatarFile);

        // 古い画像の削除処理
        if (originalAvatarUrl.current && originalAvatarUrl.current !== finalAvatarUrl) {
           await deleteImageFromR2(originalAvatarUrl.current);
        }
      }

      // DB更新
      const updates = {
        user_id: user.id,
        display_name: displayName,
        role: role,
        sub_role_1: subRole1,
        sub_role_2: subRole2,
        play_style: playStyle,
        bio: bio,
        avatar_url: finalAvatarUrl,
        updated_at: new Date().toISOString(),
      };

      const { error } = await supabase
        .from("profiles")
        .upsert(updates, { onConflict: 'user_id' });

      if (error) throw error;
      
      toast.success("プロフィールを更新しました！");
      router.push("/dashboard");

    } catch (error: any) {
      console.error(error);
      toast.error("エラー: " + error.message);
    } finally {
      setIsSubmitting(false);
    }
  };

  if (loading) return <div style={{ padding: "40px", textAlign: "center" }}>読み込み中...</div>;

  return (
    <div className="container" style={{ maxWidth: "600px", marginTop: "40px", paddingBottom: "80px" }}>
      <h1 className="section-title">プロフィール編集</h1>
      <div className="card">
        
        {/* アバター画像エリア */}
        <div style={{ textAlign: "center", marginBottom: "24px" }}>
          <div style={{ width: "100px", height: "100px", borderRadius: "50%", overflow: "hidden", background: "#eee", margin: "0 auto 12px auto" }}>
            {previewUrl ? <img src={previewUrl} alt="Avatar" style={{ width: "100%", height: "100%", objectFit: "cover" }} /> : <div style={{ width: "100%", height: "100%", display: "flex", alignItems: "center", justifyContent: "center", color: "#aaa" }}>No Image</div>}
          </div>
          <label className="btn btn-ghost" style={{ cursor: isCompressing ? "wait" : "pointer", fontSize: "0.9rem" }}>
            {isCompressing ? "画像処理中..." : "アバターを変更"}
            <input type="file" accept="image/*" onChange={handleFileSelect} style={{ display: "none" }} disabled={isCompressing || isSubmitting} />
          </label>
        </div>

        <form onSubmit={handleUpdate} style={{ display: "grid", gap: "24px" }}>
          
          <div>
            <label className="label-title">表示名 (VRChat IDなど)</label>
            <input className="input-field" type="text" value={displayName} onChange={(e) => setDisplayName(e.target.value)} required placeholder="例: kaze-san"/>
          </div>

          <div>
            <label className="label-title">メインロール (一番やりたいこと) <span style={{color:"red"}}>*</span></label>
            <select className="input-field" value={role} onChange={(e) => setRole(e.target.value)} required>
              {ROLE_OPTIONS.map(opt => <option key={opt.value} value={opt.value}>{opt.label}</option>)}
            </select>
          </div>

          <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: "16px" }}>
            <div>
              <label className="label-title">サブロール 1</label>
              <select className="input-field" value={subRole1} onChange={(e) => setSubRole1(e.target.value)}>
                <option value="">設定しない</option>
                {ROLE_OPTIONS.map(opt => <option key={opt.value} value={opt.value}>{opt.label}</option>)}
              </select>
            </div>
            <div>
              <label className="label-title">サブロール 2</label>
              <select className="input-field" value={subRole2} onChange={(e) => setSubRole2(e.target.value)}>
                <option value="">設定しない</option>
                {ROLE_OPTIONS.map(opt => <option key={opt.value} value={opt.value}>{opt.label}</option>)}
              </select>
            </div>
          </div>

          <div>
            <label className="label-title">プレイ環境 (デバイス)</label>
            <select className="input-field" value={playStyle} onChange={(e) => setPlayStyle(e.target.value)}>
              <option value="">未設定</option>
              {PLAY_STYLE_OPTIONS.map(opt => <option key={opt} value={opt}>{opt}</option>)}
            </select>
            <p style={{ fontSize: "0.8rem", color: "var(--muted)", marginTop: "4px" }}>※キャスティングの際に、フルトラッキング対応かどうかが重視される場合があります。</p>
          </div>

          <div>
            <label className="label-title">自己紹介・アピール</label>
            <textarea className="input-field" rows={6} value={bio} onChange={(e) => setBio(e.target.value)} placeholder="活動可能時間や、得意なこと、過去の実績などを書いてみましょう！"/>
          </div>

          {/* ギャラリーエリア */}
          <div style={{ marginTop: "20px", borderTop: "1px solid #eee", paddingTop: "24px" }}>
            <label className="label-title">ポートフォリオ / 活動写真 (最大4枚)</label>
            <p style={{ fontSize: "0.85rem", color: "var(--muted)", marginBottom: "16px" }}>
              あなたの魅力を伝えましょう！
            </p>

            <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: "12px" }}>
              {/* 登録済み画像の表示 */}
              {portfolioImages.map((img) => (
                <div key={img.id} style={{ position: "relative", aspectRatio: "16/9", borderRadius: "8px", overflow: "hidden", border: "1px solid #eee" }}>
                  <img src={img.image_url} alt="Portfolio" style={{ width: "100%", height: "100%", objectFit: "cover" }} />
                  <button
                    onClick={() => handleDeleteGalleryImage(img.id, img.image_url)}
                    type="button"
                    style={{
                      position: "absolute", top: "4px", right: "4px",
                      background: "rgba(0,0,0,0.6)", color: "#fff", border: "none",
                      borderRadius: "50%", width: "24px", height: "24px", cursor: "pointer",
                      display: "flex", alignItems: "center", justifyContent: "center"
                    }}
                  >
                    ×
                  </button>
                </div>
              ))}

              {/* 追加ボタン (4枚未満のときだけ表示) */}
              {portfolioImages.length < 4 && (
                <label style={{ 
                  border: "2px dashed #ccc", borderRadius: "8px", 
                  display: "flex", alignItems: "center", justifyContent: "center", 
                  aspectRatio: "16/9", cursor: isGalleryUploading ? "wait" : "pointer",
                  color: "#aaa", flexDirection: "column", gap: "4px"
                }}>
                  {isGalleryUploading ? (
                    <span style={{ fontSize: "0.8rem" }}>UP中...</span>
                  ) : (
                    <>
                      <span style={{ fontSize: "1.5rem" }}>+</span>
                      <span style={{ fontSize: "0.8rem" }}>写真を追加</span>
                    </>
                  )}
                  <input 
                    type="file" 
                    accept="image/*" 
                    onChange={handleGalleryUpload} 
                    style={{ display: "none" }} 
                    disabled={isGalleryUploading}
                  />
                </label>
              )}
            </div>
          </div>

          {/* 保存ボタン */}
          <button type="submit" className="btn btn-primary" disabled={isSubmitting || isCompressing} style={{ padding: "16px", fontSize: "1.1rem", marginTop: "24px" }}>
            {isSubmitting ? "保存中..." : "プロフィールを保存して更新"}
          </button>
        </form>
      </div>
      <style jsx>{`
        .label-title { display: block; margin-bottom: 8px; font-weight: bold; color: #333; }
        .input-field { width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 1rem; background: #fff; }
        .input-field:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 3px rgba(124, 58, 237, 0.1); }
      `}</style>
    </div>
  );
}


----------------------------------------
### FILE: page.tsx ###
----------------------------------------
"use client";

import { useEffect, useState, useCallback } from "react"; // useCallbackを追加
import { supabase } from "@/lib/supabase";
import Link from "next/link";
import { useRouter } from "next/navigation";
import { ROLE_OPTIONS } from "@/lib/constants"; 
import OfferReplyModal from "@/components/OfferReplyModal";
import BookmarkModal from "@/components/BookmarkModal";

export default function Dashboard() {
  const [editBookmarkTarget, setEditBookmarkTarget] = useState<any>(null); // 編集用
  const router = useRouter();
  const [loading, setLoading] = useState(true);
  const [user, setUser] = useState<any>(null);
  const [profile, setProfile] = useState<any>(null);

  const [myEvents, setMyEvents] = useState<any[]>([]);
  const [myEntries, setMyEntries] = useState<any[]>([]);
  const [bookmarkedEvents, setBookmarkedEvents] = useState<any[]>([]);
  const [bookmarkedCasts, setBookmarkedCasts] = useState<any[]>([]);
  const [receivedCastLikes, setReceivedCastLikes] = useState(0);
  const [receivedEventLikes, setReceivedEventLikes] = useState(0);

  const [receivedOffers, setReceivedOffers] = useState<any[]>([]);
  const [sentOffers, setSentOffers] = useState<any[]>([]);

  // ▼▼▼ モーダル制御用のステートを追加 ▼▼▼
  const [selectedOffer, setSelectedOffer] = useState<any>(null);
  const [isReplyModalOpen, setIsReplyModalOpen] = useState(false);

  const [activeTab, setActiveTab] = useState<"manage" | "bookmarks">("manage");

  const pendingOffers = receivedOffers.filter(o => o.status === 'pending');
  const historyOffers = receivedOffers.filter(o => o.status !== 'pending');
  const getRoleLabel = (value: string | null) => {
    if (!value) return "未設定";
    const found = ROLE_OPTIONS.find((opt) => opt.value === value);
    return found ? found.label : value;
  };

  const StatusBadge = ({ status }: { status: string }) => {
    switch (status) {
      case "pending": case "Pending":
        return <span style={{ background: "#fbbf24", color: "#fff", padding: "4px 12px", borderRadius: "99px", fontSize: "0.8rem", fontWeight: "bold" }}>返信待ち</span>;
      case "accepted": case "Accepted":
        return <span style={{ background: "#34d399", color: "#fff", padding: "4px 12px", borderRadius: "99px", fontSize: "0.8rem", fontWeight: "bold" }}>承諾済み</span>;
      case "rejected": case "Rejected":
        return <span style={{ background: "#9ca3af", color: "#fff", padding: "4px 12px", borderRadius: "99px", fontSize: "0.8rem", fontWeight: "bold" }}>見送り</span>;
      default:
        return <span style={{ background: "#eee", color: "#666", padding: "4px 12px", borderRadius: "99px", fontSize: "0.8rem" }}>{status}</span>;
    }
  };

  // ▼▼▼ データ取得処理を関数化して、更新時に再利用できるようにする ▼▼▼
  const fetchData = useCallback(async () => {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) {
      router.push("/login");
      return;
    }
    setUser(user);

    const { data: profileData } = await supabase.from("profiles").select("*").eq("user_id", user.id).single();
    setProfile(profileData);

    const { data: eventsData } = await supabase.from("events").select("*").eq("organizer_id", user.id).order("created_at", { ascending: false });
    if (eventsData) setMyEvents(eventsData);

    const { data: entriesData } = await supabase.from("entries").select("*, event:events(title, id)").eq("cast_id", user.id).order("created_at", { ascending: false });
    if (entriesData) setMyEntries(entriesData);

    const { data: bmEvents } = await supabase.from("event_bookmarks").select("created_at, event:events(*)").eq("user_id", user.id).order("created_at", { ascending: false });
    if (bmEvents) setBookmarkedEvents(bmEvents.map((item: any) => item.event).filter((e: any) => e !== null));

const { data: bmCasts } = await supabase
      .from("cast_bookmarks")
      .select("id, memo, created_at, cast:profiles!target_cast_id(*)") // memoを追加
      .eq("user_id", user.id)
      .order("created_at", { ascending: false });
    
    if (bmCasts) setBookmarkedCasts(bmCasts); // mapせずそのままセット
    const { count: castLikeCount } = await supabase.from("profile_likes").select("id", { count: 'exact', head: true }).eq("target_cast_id", user.id);
    setReceivedCastLikes(castLikeCount || 0);

    const myEventIds = eventsData?.map(e => e.id) || [];
    if (myEventIds.length > 0) {
      const { count: eventLikeCount } = await supabase.from("likes").select("id", { count: 'exact', head: true }).in("event_id", myEventIds);
      setReceivedEventLikes(eventLikeCount || 0);
    }

    // オファー情報の取得
    const { data: rOffers } = await supabase
      .from("offers")
      .select("*, event:events(title, id), sender:profiles!sender_id(display_name, avatar_url)")
      .eq("receiver_id", user.id)
      .order("created_at", { ascending: false });
    if (rOffers) setReceivedOffers(rOffers);

    const { data: sOffers } = await supabase
      .from("offers")
      .select("*, event:events(title, id), receiver:profiles!receiver_id(display_name, avatar_url)")
      .eq("sender_id", user.id)
      .order("created_at", { ascending: false });
    if (sOffers) setSentOffers(sOffers);

    setLoading(false);
  }, [router]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  const handleLogout = async () => {
    if(!confirm("ログアウトしますか？")) return;
    await supabase.auth.signOut();
    router.push("/login");
  };

  // ▼▼▼ オファーをクリックした時の処理 ▼▼▼
  const handleOfferClick = (offer: any) => {
    setSelectedOffer(offer);
    setIsReplyModalOpen(true);
  };

  if (loading) return <div style={{ padding: "40px", textAlign: "center" }}>読み込み中...</div>;

  return (
    <>
      <header className="site-header">
         {/* (ヘッダーは変更なし) */}
        <div className="container header-inner" style={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
          <Link href="/dashboard" className="logo-wrap" style={{ textDecoration: 'none' }}>
            <div className="logo-mark">C</div>
            <div className="logo-text-block">
              <div className="logo-text-main">Castket</div>
              <div className="logo-text-sub">Dashboard</div>
            </div>
          </Link>
          <button onClick={handleLogout} className="btn btn-ghost" style={{ fontSize: "0.9rem" }}>
            🚪 ログアウト
          </button>
        </div>
      </header>

      <main className="section section-soft" style={{ minHeight: "100vh" }}>
        <div className="container">
          
          {/* プロフィールカード */}
          <div className="card" style={{ display: "flex", alignItems: "center", gap: "24px", marginBottom: "32px", padding: "32px" }}>
            <div style={{ width: "80px", height: "80px", borderRadius: "50%", border: "4px solid #f0f0f0", overflow: "hidden", background: "#eee", flexShrink: 0 }}>
              {profile?.avatar_url ? (
                // eslint-disable-next-line @next/next/no-img-element
                <img src={profile.avatar_url} alt="My Icon" style={{ width: "100%", height: "100%", objectFit: "cover" }} />
              ) : (
                <div style={{ width: "100%", height: "100%", display: "flex", alignItems: "center", justifyContent: "center", fontSize: "2rem", color: "#ccc" }}>👤</div>
              )}
            </div>
            
            <div style={{ flex: 1 }}>
              <h1 style={{ margin: "0 0 8px 0", fontSize: "1.8rem" }}>{profile?.display_name || "ゲスト"}</h1>
              
              <div style={{ display: "flex", flexDirection: "column", gap: "6px" }}>
                <div style={{ display: "flex", gap: "12px", alignItems: "center", flexWrap: "wrap" }}>
                  <span className="badge main-badge">{getRoleLabel(profile?.role)}</span>
                  <Link href="/dashboard/profile" style={{ fontSize: "0.85rem", color: "var(--accent)", textDecoration: "none", fontWeight: "bold" }}>
                    ⚙️ プロフィール編集
                  </Link>
                </div>

                {(profile?.sub_role_1 || profile?.sub_role_2) && (
                  <div style={{ display: "flex", gap: "6px", flexWrap: "wrap" }}>
                    {profile.sub_role_1 && <span className="badge sub-badge">{getRoleLabel(profile.sub_role_1)}</span>}
                    {profile.sub_role_2 && <span className="badge sub-badge">{getRoleLabel(profile.sub_role_2)}</span>}
                  </div>
                )}
              </div>
            </div>
          </div>

          {/* スタッツ */}
          <div style={{ display: "grid", gridTemplateColumns: "repeat(auto-fit, minmax(200px, 1fr))", gap: "16px", marginBottom: "40px" }}>
             <div className="stat-card">
               <div className="stat-icon">💎</div>
               <div>
                 <div style={{ fontSize: "0.8rem", opacity: 0.9 }}>Total Likes</div>
                 <div style={{ fontSize: "1.5rem", fontWeight: "bold", lineHeight: 1.2 }}>{receivedCastLikes + receivedEventLikes}</div>
               </div>
             </div>
             <div className="stat-card">
               <div className="stat-icon">❤️</div>
               <div>
                 <div style={{ fontSize: "0.8rem", color: "var(--muted)" }}>Cast Likes</div>
                 <div style={{ fontSize: "1.5rem", fontWeight: "bold", lineHeight: 1.2 }}>{receivedCastLikes}</div>
               </div>
             </div>
             <div className="stat-card">
               <div className="stat-icon">💛</div>
               <div>
                 <div style={{ fontSize: "0.8rem", color: "var(--muted)" }}>Event Likes</div>
                 <div style={{ fontSize: "1.5rem", fontWeight: "bold", lineHeight: 1.2 }}>{receivedEventLikes}</div>
               </div>
             </div>
          </div>

          {/* クイックアクション */}
          <div style={{ marginBottom: "40px" }}>
              <h2 className="section-title" style={{ margin: "0 0 16px 0", textAlign: "left", fontSize: "1.2rem" }}>🚀 クイックアクション</h2>
              <div className="menu-grid">
                <Link href="/dashboard/events" className="menu-card primary">
                  <div className="menu-icon">📝</div>
                  <div>
                    <div className="menu-title">イベントを管理・作成</div>
                    <div className="menu-desc">主催イベントの編集や確認</div>
                  </div>
                </Link>
                <Link href="/events" className="menu-card">
                  <div className="menu-icon">📅</div>
                  <div>
                    <div className="menu-title">イベントを探す</div>
                    <div className="menu-desc">参加したいイベントを見つける</div>
                  </div>
                </Link>
                <Link href="/casts" className="menu-card">
                  <div className="menu-icon">🎤</div>
                  <div>
                    <div className="menu-title">キャストを探す</div>
                    <div className="menu-desc">出演者やスタッフを探す</div>
                  </div>
                </Link>
                <Link href="/" className="menu-card">
                  <div className="menu-icon">🏠</div>
                  <div>
                    <div className="menu-title">トップページへ</div>
                    <div className="menu-desc">Castketのホームに戻る</div>
                  </div>
                </Link>
              </div>
          </div>

          <div style={{ display: "flex", gap: "0", borderBottom: "2px solid #ddd", marginBottom: "32px" }}>
            <button onClick={() => setActiveTab("manage")} style={{ padding: "12px 24px", background: "none", border: "none", borderBottom: activeTab === "manage" ? "3px solid var(--accent)" : "3px solid transparent", color: activeTab === "manage" ? "var(--accent)" : "var(--muted)", fontWeight: "bold", cursor: "pointer", fontSize: "1rem" }}>📝 自分の活動</button>
            <button onClick={() => setActiveTab("bookmarks")} style={{ padding: "12px 24px", background: "none", border: "none", borderBottom: activeTab === "bookmarks" ? "3px solid #333" : "3px solid transparent", color: activeTab === "bookmarks" ? "#333" : "var(--muted)", fontWeight: "bold", cursor: "pointer", fontSize: "1rem" }}>🔖 ブックマーク</button>
          </div>

          {activeTab === "manage" && (
            <div style={{ display: "grid", gap: "40px" }}>


              {/* 送ったオファー */}
              {sentOffers.length > 0 && (
                <section>
                  <h3 className="section-lead" style={{ textAlign: "left", marginBottom: "16px" }}>📤 送ったオファー</h3>
                  <div style={{ display: "grid", gap: "16px" }}>
                    {sentOffers.map((offer) => (
                      <div key={offer.id} className="card" style={{ display: "flex", justifyContent: "space-between", alignItems: "center", opacity: offer.status === 'rejected' ? 0.7 : 1 }}>
                        <div style={{ display: "flex", alignItems: "center", gap: "12px" }}>
                           <div style={{width: "40px", height: "40px", borderRadius: "50%", background: "#eee", overflow: "hidden"}}>
                              {offer.receiver?.avatar_url && <img src={offer.receiver.avatar_url} style={{width:"100%", height:"100%", objectFit:"cover"}} />}
                           </div>
                           <div>
                              <div style={{ fontWeight: "bold" }}>
                                To: {offer.receiver?.display_name} さん
                              </div>
                              <div style={{ fontSize: "0.85rem", color: "var(--muted)" }}>
                                イベント: {offer.event?.title}
                              </div>
                           </div>
                        </div>
                        <div style={{ display: "flex", flexDirection: "column", alignItems: "flex-end", gap: "4px" }}>
                          <StatusBadge status={offer.status} />
                          <span style={{ fontSize: "0.75rem", color: "var(--muted)" }}>{new Date(offer.created_at).toLocaleDateString()}</span>
                        </div>
                      </div>
                    ))}
                  </div>
                </section>
              )}

              <section>
                <h3 className="section-lead" style={{ textAlign: "left", marginBottom: "16px" }}>🙋‍♂️ 応募したイベント</h3>
                {myEntries.length === 0 ? <div className="card" style={{ color: "var(--muted)" }}>まだ応募履歴はありません。</div> : (
                  <div style={{ display: "grid", gap: "16px" }}>
                    {myEntries.map((entry) => (
                      entry.event?.id ? (
                        <Link href={`/events/${entry.event.id}`} key={entry.id} style={{ textDecoration: "none", color: "inherit" }}>
                          <div className="card hover-card" style={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
                            <div>
                              <div style={{ fontWeight: "bold", fontSize: "1.1rem" }}>{entry.event.title}</div>
                              <div style={{ fontSize: "0.85rem", color: "var(--muted)" }}>応募日: {new Date(entry.created_at).toLocaleDateString()}</div>
                            </div>
                            <div>
                              <StatusBadge status={entry.status} />
                            </div>
                          </div>
                        </Link>
                      ) : (
                         <div key={entry.id} className="card" style={{ display: "flex", justifyContent: "space-between", alignItems: "center", opacity: 0.6 }}>
                           {/* ... */}
                         </div>
                      )
                    ))}
                  </div>
                )}
              </section>

              {/* ... (主催イベント部分はそのまま) ... */}
              <section>
                <h3 className="section-lead" style={{ textAlign: "left", marginBottom: "16px" }}>🚩 主催したイベント</h3>
                {myEvents.length === 0 ? <div className="card" style={{ color: "var(--muted)" }}>まだイベントを作成していません。</div> : (
                  <div style={{ display: "grid", gap: "16px" }}>
                    {myEvents.map((event) => (
                      <Link href={`/dashboard/events/${event.id}`} key={event.id} style={{ textDecoration: "none", color: "inherit" }}>
                        <div className="card hover-card" style={{ padding: "16px", display: "flex", alignItems: "center", gap: "16px" }}>
                          {event.banner_url && <img src={event.banner_url} alt="" style={{ width: "60px", height: "60px", objectFit: "cover", borderRadius: "8px" }} />}
                          <div style={{ flex: 1 }}><div style={{ fontWeight: "bold" }}>{event.title}</div><div style={{ fontSize: "0.85rem", color: "var(--muted)" }}>{event.schedule_type === "one_time" ? event.event_date : "定期/不定期"}</div></div>
                          <div style={{ fontSize: "0.9rem", color: "var(--accent)", fontWeight: "bold" }}>応募管理へ &rarr;</div>
                        </div>
                      </Link>
                    ))}
                  </div>
                )}
              </section>
            </div>
          )}

{activeTab === "bookmarks" && (
            <div style={{ display: "grid", gap: "40px" }}>
               {/* 1. 保存したイベント */}
               <section>
                  <h3 className="section-lead" style={{ textAlign: "left", marginBottom: "16px" }}>🔖 保存したイベント</h3>
                  {bookmarkedEvents.length === 0 ? (
                     <div className="card" style={{ color: "var(--muted)" }}>まだブックマークしたイベントはありません。</div> 
                  ) : (
                     <div style={{ display: "grid", gridTemplateColumns: "repeat(auto-fill, minmax(280px, 1fr))", gap: "20px" }}>
                        {bookmarkedEvents.map((event) => (
                        <Link href={`/events/${event.id}`} key={event.id} style={{ textDecoration: "none", color: "inherit" }}>
                           <article className="card hover-up" style={{ padding: "0", overflow: "hidden" }}>
                                 <div style={{ width: "100%", aspectRatio: "16/9", background: "#eee" }}>
                                   {event.banner_url ? <img src={event.banner_url} alt="" style={{ width: "100%", height: "100%", objectFit: "cover" }} /> : null}
                                 </div>
                                 <div style={{ padding: "12px" }}>
                                   <div style={{ fontWeight: "bold", marginBottom: "4px" }}>{event.title}</div>
                                 </div>
                           </article>
                        </Link>
                        ))}
                     </div>
                  )}
               </section>

               {/* 2. 保存したキャスト (メモ機能付き) */}
               <section>
                  <h3 className="section-lead" style={{ textAlign: "left", marginBottom: "16px" }}>🔖 保存したキャスト</h3>
                  {bookmarkedCasts.length === 0 ? (
                     <div className="card" style={{ color: "var(--muted)" }}>まだブックマークしたキャストはいません。</div> 
                  ) : (
                     <div style={{ display: "grid", gridTemplateColumns: "repeat(auto-fill, minmax(300px, 1fr))", gap: "16px" }}>
                        {bookmarkedCasts.map((item) => {
                          // item は cast_bookmarks テーブルの行データ
                          const cast = item.cast; 
                          if(!cast) return null;
                          
                          return (
                            <div key={item.id} className="card hover-up" style={{ padding: "16px", display: "flex", flexDirection: "column", gap: "12px" }}>
                               {/* キャスト情報部分 */}
                               <Link href={`/casts/${cast.user_id}`} style={{ textDecoration: "none", color: "inherit", display: "flex", alignItems: "center", gap: "12px" }}>
                                  <div style={{ width: "50px", height: "50px", borderRadius: "50%", background: "#eee", overflow: "hidden", flexShrink: 0 }}>
                                    {cast.avatar_url && <img src={cast.avatar_url} alt="" style={{ width: "100%", height: "100%", objectFit: "cover" }} />}
                                  </div>
                                  <div>
                                     <div style={{ fontWeight: "bold", fontSize: "1rem" }}>{cast.display_name}</div>
                                     <div style={{ fontSize: "0.8rem", color: "var(--muted)" }}>{getRoleLabel(cast.role)}</div>
                                  </div>
                               </Link>

                               {/* メモ表示エリア */}
                               <div style={{ background: "#f9f9f9", padding: "10px", borderRadius: "8px", fontSize: "0.85rem", color: "#555", position: "relative" }}>
                                 {item.memo ? (
                                   <div style={{ whiteSpace: "pre-wrap" }}>📝 {item.memo}</div>
                                 ) : (
                                   <div style={{ color: "#aaa", fontStyle: "italic" }}>メモなし</div>
                                 )}
                                 
                                 {/* 編集ボタン */}
                                 <button 
                                   onClick={() => setEditBookmarkTarget({ id: cast.user_id, name: cast.display_name })}
                                   style={{ position: "absolute", top: "8px", right: "8px", background: "none", border: "none", cursor: "pointer", color: "var(--accent)", fontSize: "0.8rem", fontWeight: "bold" }}
                                 >
                                   編集
                                 </button>
                               </div>
                            </div>
                          );
                        })}
                     </div>
                  )}
               </section>
            </div>
          )}        </div>
      </main>
      
      {/* ▼▼▼ モーダルを表示 ▼▼▼ */}
      <OfferReplyModal
        isOpen={isReplyModalOpen}
        onClose={() => setIsReplyModalOpen(false)}
        offer={selectedOffer}
        onUpdate={fetchData} // 返信後にデータを再取得
      />

{/* ▼▼▼ ブックマーク編集モーダル ▼▼▼ */}
      {editBookmarkTarget && user && (
        <BookmarkModal
          isOpen={true}
          onClose={() => setEditBookmarkTarget(null)}
          targetId={editBookmarkTarget.id}
          targetName={editBookmarkTarget.name}
          userId={user.id}
          onUpdate={fetchData} // 編集・削除したらリストを更新
        />
      )}

      <style jsx>{`
        .main-badge { background: rgba(124, 58, 237, 0.1); color: var(--accent); padding: 6px 16px; borderRadius: 99px; font-size: 0.9rem; font-weight: bold; border: 1px solid rgba(124, 58, 237, 0.2); }
        .sub-badge { background: #f5f5f5; color: #666; padding: 4px 10px; borderRadius: 99px; font-size: 0.75rem; border: 1px solid #ddd; }
        .hover-card:hover { background-color: #fdfaff; border-color: var(--accent); }
        .hover-up { transition: transform 0.2s; }
        .hover-up:hover { transform: translateY(-4px); }
      `}</style>
    </>
  );
}


----------------------------------------
### FILE: page.tsx ###
----------------------------------------
"use client";

import { useEffect, useState } from "react";
import { supabase } from "@/lib/supabase";
import Link from "next/link";
import { WEEKDAY_MAP } from "@/lib/constants";

export default function PastEventsPage() {
  const [events, setEvents] = useState<any[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchEvents = async () => {
      const { data, error } = await supabase
        .from("events")
        .select("*");

      if (error) {
        console.error(error);
        setLoading(false);
        return;
      }

      if (data) {
        const todayStr = new Date().toISOString().split("T")[0];

        // ▼▼▼ 判定ロジック：終わったイベントだけを残す ▼▼▼
        const pastEvents = data.filter((event) => {
          // 単発: 開催日が「昨日以前」ならOK
          if (event.schedule_type === "one_time") {
            return event.event_date < todayStr;
          }
          // 不定期: 全ての日付が「昨日以前」ならOK
          // (未来の日付が1つでも残っていれば、それはまだ現役イベント)
          if (event.schedule_type === "irregular" && event.irregular_dates) {
            return event.irregular_dates.every((d: string) => d < todayStr);
          }
          // 定期(毎週): 基本的に終わらないので、過去ログには出さない（ずっと現役）
          if (event.schedule_type === "weekly") {
            return false;
          }
          return false;
        });

        // ▼▼▼ 並び替え：最近終わったもの順（降順） ▼▼▼
        const sortedEvents = pastEvents.sort((a, b) => {
          const dateA = getLastEventDate(a);
          const dateB = getLastEventDate(b);
          // 新しい日付が大きいので、b - a で降順にする
          if (dateA < dateB) return 1;
          if (dateA > dateB) return -1;
          return 0;
        });

        setEvents(sortedEvents);
      }
      setLoading(false);
    };

    fetchEvents();
  }, []);

  // 最後に開催した日を取得するヘルパー
  const getLastEventDate = (event: any) => {
    if (event.schedule_type === "one_time") {
      return event.event_date || "0000-00-00";
    }
    if (event.schedule_type === "irregular" && event.irregular_dates) {
      // 日付をソートして一番最後のものを取る
      const sortedDates = event.irregular_dates.sort();
      return sortedDates[sortedDates.length - 1] || "0000-00-00";
    }
    return "0000-00-00";
  };

  const formatTime = (time: string) => (time ? time.slice(0, 5) : "");

  if (loading) return <div style={{ padding: "40px", textAlign: "center" }}>読み込み中...</div>;

  return (
    <>
      <header className="site-header">
        <div className="container header-inner">
          <Link href="/events" className="logo-wrap" style={{ textDecoration: 'none' }}>
            <div className="logo-mark">C</div>
            <div className="logo-text-block">
              <div className="logo-text-main">Castket</div>
              <div className="logo-text-sub">Archive</div>
            </div>
          </Link>
          <div className="header-actions">
            <Link href="/events" className="btn btn-ghost">一覧に戻る</Link>
          </div>
        </div>
      </header>

      <main className="section section-soft" style={{ minHeight: "100vh" }}>
        <div className="container">
          <h1 className="section-title" style={{ textAlign: "left", marginBottom: "32px", color: "var(--muted)" }}>
            📜 過去のイベントログ
          </h1>

          {events.length === 0 ? (
            <div style={{ textAlign: "center", padding: "60px", color: "var(--muted)" }}>
              <p>過去のイベント履歴はありません。</p>
            </div>
          ) : (
            <div style={{ display: "grid", gridTemplateColumns: "repeat(auto-fill, minmax(300px, 1fr))", gap: "24px" }}>
              {events.map((event) => (
                <Link href={`/events/${event.id}`} key={event.id} style={{ textDecoration: "none", color: "inherit" }}>
                  <article className="card" style={{ padding: "0", overflow: "hidden", height: "100%", display: "flex", flexDirection: "column", opacity: 0.8, filter: "grayscale(30%)" }}>
                    
                    {/* 画像エリア */}
                    <div style={{ width: "100%", aspectRatio: "16/9", background: "#eee", position: "relative" }}>
                      {event.banner_url ? (
                        // eslint-disable-next-line @next/next/no-img-element
                        <img src={event.banner_url} alt={event.title} style={{ width: "100%", height: "100%", objectFit: "cover" }} />
                      ) : (
                        <div style={{ width: "100%", height: "100%", display: "flex", alignItems: "center", justifyContent: "center", color: "#aaa", fontWeight: "bold" }}>NO IMAGE</div>
                      )}
                      <div style={{ position: "absolute", top: "12px", left: "12px", background: "#666", color: "#fff", padding: "4px 12px", borderRadius: "99px", fontSize: "0.75rem", fontWeight: "bold" }}>
                        終了
                      </div>
                    </div>

                    <div style={{ padding: "20px", flex: 1, display: "flex", flexDirection: "column" }}>
                      <h2 style={{ fontSize: "1.1rem", fontWeight: "bold", marginBottom: "8px", color: "var(--text)" }}>
                        {event.title}
                      </h2>
                      <div style={{ marginTop: "auto", fontSize: "0.9rem", color: "var(--muted)" }}>
                        開催日: {event.schedule_type === "one_time" ? event.event_date : "全日程終了"}
                      </div>
                    </div>
                  </article>
                </Link>
              ))}
            </div>
          )}
        </div>
      </main>
    </>
  );
}


----------------------------------------
### FILE: page.tsx ###
----------------------------------------


----------------------------------------
### FILE: page.tsx ###
----------------------------------------
"use client";

import { useEffect, useState } from "react";
import { supabase } from "@/lib/supabase";
import Link from "next/link";
import dayjs from "dayjs";
import "dayjs/locale/ja";
// ▼ 定数をインポート
import { EVENT_TAGS, WEEKDAY_MAP } from "@/lib/constants";

dayjs.locale("ja");

export default function EventListPage() {
  // ▼▼▼ 追加: 日付・時間の表示を整える関数 ▼▼▼
// ▼▼▼ 修正: 日付と時間を分かりやすくデザインして表示する関数 ▼▼▼
  const renderEventSchedule = (event: any) => {
    // 秒を削る
    const start = event.start_time ? event.start_time.slice(0, 5) : "";
    const end = event.end_time ? event.end_time.slice(0, 5) : "";
    const timeStr = start || end ? `${start} ~ ${end}` : "";

    let dateContent;

    // スケジュールタイプごとの日付表示
    if (event.schedule_type === "one_time") {
      dateContent = (
        <>
          <span style={{ marginRight: "4px" }}>📅</span>
          {event.event_date}
        </>
      );
    } else if (event.schedule_type === "weekly") {
      const days = event.weekdays && Array.isArray(event.weekdays)
        ? event.weekdays.map((d: string) => WEEKDAY_MAP[d] || d).join("・")
        : "曜日未定";
      dateContent = (
        <>
          <span style={{ marginRight: "4px" }}>🔄</span>
          毎週 <span>{days}曜</span>
        </>
      );
    } else {
      dateContent = <span>❓ 不定期</span>;
    }

    return (
      <div style={{ display: "flex", flexWrap: "wrap", alignItems: "center", gap: "8px" }}>
        {/* 日付エリア: 強調カラー */}
        <div style={{ 
          color: "var(--accent)", 
          fontWeight: "bold", 
          fontSize: "0.9rem",
          display: "flex", 
          alignItems: "center"
        }}>
          {dateContent}
        </div>
        
        {/* 時間エリア: グレー背景で区別 */}
        {timeStr && (
          <div style={{ 
            display: "flex", 
            alignItems: "center", 
            gap: "4px", 
            fontSize: "0.8rem", 
            color: "#555", 
            background: "#f3f4f6", // 薄いグレーの背景
            padding: "2px 8px", 
            borderRadius: "4px",
            border: "1px solid #eee"
          }}>
            <span>⏰</span>
            <span style={{ fontFamily: "monospace", fontWeight: "bold" }}>{timeStr}</span>
          </div>
        )}
      </div>
    );
  };

  const [events, setEvents] = useState<any[]>([]);
  const [loading, setLoading] = useState(true);
  
  const [viewMode, setViewMode] = useState<"grid" | "list" | "compact">("grid");
  const [sortBy, setSortBy] = useState<"date" | "likes" | "capacity">("date");

  // 絞り込みステート
  const [filterFreq, setFilterFreq] = useState<string | null>(null);
  const [filterTime, setFilterTime] = useState<string | null>(null);
  const [filterGenre, setFilterGenre] = useState<string | null>(null);

  useEffect(() => {
    const fetchEvents = async () => {
      const { data, error } = await supabase
        .from("events")
        .select("*, likes(count)") 
        .order("created_at", { ascending: false });

      if (error) {
        console.error(error);
      } else {
        const formattedEvents = (data || []).map((event: any) => ({
          ...event,
          likesCount: event.likes ? event.likes[0]?.count || 0 : 0,
          tags: event.tags || []
        }));
        setEvents(formattedEvents);
      }
      setLoading(false);
    };

    fetchEvents();
  }, []);

  // 絞り込みロジック
  const filteredEvents = events.filter((event) => {
    if (filterFreq) {
      if (event.schedule_type !== filterFreq) return false;
    }
    if (filterTime) {
      if (event.schedule_type === "one_time" && event.event_date) {
        const eventDate = dayjs(event.event_date);
        const now = dayjs();
        if (filterTime === "this_month") {
          if (!eventDate.isSame(now, "month")) return false;
        } else if (filterTime === "next_month") {
          if (!eventDate.isSame(now.add(1, "month"), "month")) return false;
        } else if (filterTime === "future") {
          const endOfNextMonth = now.add(1, "month").endOf("month");
          if (!eventDate.isAfter(endOfNextMonth)) return false;
        }
      }
    }
    // ▼ constantsのタグで絞り込み
    if (filterGenre) {
      if (!event.tags || !event.tags.includes(filterGenre)) return false;
    }
    return true;
  });

  // 並べ替えロジック
  const sortedEvents = [...filteredEvents].sort((a, b) => {
    if (sortBy === "date") {
      return dayjs(a.event_date).diff(dayjs(b.event_date));
    }
    if (sortBy === "likes") {
      return b.likesCount - a.likesCount;
    }
    if (sortBy === "capacity") {
      const capA = a.capacity || 9999;
      const capB = b.capacity || 9999;
      return capA - capB;
    }
    return 0;
  });

  const clearFilters = () => {
    setFilterFreq(null);
    setFilterTime(null);
    setFilterGenre(null);
  };

  if (loading) return <div style={{ padding: "40px", textAlign: "center" }}>読み込み中...</div>;

  return (
    <>
      <header className="site-header">
        <div className="container header-inner">
          <Link href="/" className="logo-wrap" style={{ textDecoration: 'none' }}>
            <div className="logo-mark">C</div>
            <div className="logo-text-block">
              <div className="logo-text-main">Castket</div>
              <div className="logo-text-sub">Event List</div>
            </div>
          </Link>
          <div className="header-actions">
            <Link href="/dashboard" className="btn btn-ghost">マイページへ</Link>
          </div>
        </div>
      </header>

      <main className="section section-soft" style={{ minHeight: "100vh" }}>
        <div className="container">
          
          <div style={{ marginBottom: "24px" }}>
            <h1 className="section-title" style={{ margin: "0 0 16px 0", textAlign: "left" }}>キャスト募集中のイベント</h1>
            
            <div className="filter-box" style={{ background: "#fff", padding: "20px", borderRadius: "12px", border: "1px solid #eee", marginBottom: "24px" }}>
              <div style={{ fontSize: "0.9rem", fontWeight: "bold", marginBottom: "12px", color: "#333", display: "flex", justifyContent: "space-between" }}>
                <span>🔍 条件で絞り込む</span>
                {(filterFreq || filterTime || filterGenre) && (
                  <button onClick={clearFilters} style={{ background: "none", border: "none", color: "#ff4757", cursor: "pointer", fontSize: "0.85rem", textDecoration: "underline" }}>
                    × 条件をクリア
                  </button>
                )}
              </div>
              
              <div style={{ display: "flex", flexDirection: "column", gap: "16px" }}>
                <div className="filter-row">
                  <span className="filter-label">頻度:</span>
                  <div className="filter-options">
                    <button className={`filter-chip ${filterFreq === "weekly" ? "active" : ""}`} onClick={() => setFilterFreq(filterFreq === "weekly" ? null : "weekly")}>毎週</button>
                    <button className={`filter-chip ${filterFreq === "one_time" ? "active" : ""}`} onClick={() => setFilterFreq(filterFreq === "one_time" ? null : "one_time")}>単発</button>
                    <button className={`filter-chip ${filterFreq === "irregular" ? "active" : ""}`} onClick={() => setFilterFreq(filterFreq === "irregular" ? null : "irregular")}>不定期</button>
                  </div>
                </div>

                <div className="filter-row">
                  <span className="filter-label">時期:</span>
                  <div className="filter-options">
                    <button className={`filter-chip ${filterTime === "this_month" ? "active" : ""}`} onClick={() => setFilterTime(filterTime === "this_month" ? null : "this_month")}>今月</button>
                    <button className={`filter-chip ${filterTime === "next_month" ? "active" : ""}`} onClick={() => setFilterTime(filterTime === "next_month" ? null : "next_month")}>来月</button>
                    <button className={`filter-chip ${filterTime === "future" ? "active" : ""}`} onClick={() => setFilterTime(filterTime === "future" ? null : "future")}>再来月以降</button>
                  </div>
                </div>

                {/* ▼ constants の EVENT_TAGS を使用 */}
                <div className="filter-row">
                  <span className="filter-label">タグ:</span>
                  <div className="filter-options">
                    {EVENT_TAGS.map((g) => (
                      <button 
                        key={g} 
                        className={`filter-chip ${filterGenre === g ? "active" : ""}`} 
                        onClick={() => setFilterGenre(filterGenre === g ? null : g)}
                      >
                        {g}
                      </button>
                    ))}
                  </div>
                </div>
              </div>
            </div>

            <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", flexWrap: "wrap", gap: "16px" }}>
              <p style={{ margin: 0, color: "#666", fontSize: "0.9rem" }}>
                <b>{sortedEvents.length}</b> 件ヒット
              </p>
              
              <div style={{ display: "flex", alignItems: "center", gap: "16px", flexWrap: "wrap" }}>
                <div style={{ display: "flex", alignItems: "center", gap: "8px" }}>
                  <select value={sortBy} onChange={(e) => setSortBy(e.target.value as any)} className="sort-select">
                    <option value="date">📅 開催日が近い順</option>
                    <option value="likes">💖 人気順 (Like)</option>
                    <option value="capacity">👥 募集人数が少ない順</option>
                  </select>
                </div>
                <div className="view-toggle-area" style={{ margin: 0 }}>
                  <button className={`view-btn ${viewMode === "grid" ? "active" : ""}`} onClick={() => setViewMode("grid")} title="グリッド">田</button>
                  <button className={`view-btn ${viewMode === "list" ? "active" : ""}`} onClick={() => setViewMode("list")} title="リスト">☰</button>
                  <button className={`view-btn ${viewMode === "compact" ? "active" : ""}`} onClick={() => setViewMode("compact")} title="テキスト">≣</button>
                </div>
              </div>
            </div>
          </div>
          
          {/* イベントリスト描画 */}
          {sortedEvents.length === 0 ? (
            <div className="card" style={{ textAlign: "center", padding: "60px" }}>
              <p>条件に一致するイベントはありませんでした。</p>
              <button onClick={clearFilters} className="btn btn-ghost" style={{ marginTop: "16px" }}>条件をリセットする</button>
            </div>
          ) : (
            <div className={`event-grid event-container ${viewMode === "list" ? "list-view" : ""} ${viewMode === "compact" ? "compact-view" : ""}`} style={{ display: "grid", gap: "24px", gridTemplateColumns: "repeat(auto-fill, minmax(300px, 1fr))" }}>
              {sortedEvents.map((event) => (
                <div key={event.id} className={`card hover-up event-card ${viewMode === "list" ? "list-view" : ""} ${viewMode === "compact" ? "compact-view" : ""}`} style={{ padding: "0", overflow: "hidden", display: "flex", flexDirection: "column" }}>
                  <div className="card-image" style={{ width: "100%", aspectRatio: "16/9", background: "#f0f0f0", position: "relative" }}>
                    <div style={{ position: "absolute", top: "8px", left: "8px", display: "flex", gap: "4px", flexWrap: "wrap" }}>
                      <span style={{ background: "rgba(0,0,0,0.6)", color: "#fff", padding: "4px 8px", borderRadius: "4px", fontSize: "0.75rem", fontWeight: "bold" }}>
                        {event.schedule_type === "one_time" ? "単発" : event.schedule_type === "weekly" ? "毎週" : "不定期"}
                      </span>
                      {/* タグ表示 */}
                      {event.tags && event.tags.map((tag: string) => (
                         <span key={tag} style={{ background: "rgba(124, 58, 237, 0.9)", color: "#fff", padding: "4px 8px", borderRadius: "4px", fontSize: "0.75rem", fontWeight: "bold" }}>
                           {tag}
                         </span>
                      ))}
                    </div>
                    {event.capacity && (
                      <div style={{ position: "absolute", bottom: "8px", right: "8px" }}>
                        <span style={{ background: "rgba(255,255,255,0.9)", color: "#333", padding: "4px 8px", borderRadius: "4px", fontSize: "0.75rem", fontWeight: "bold", boxShadow: "0 2px 4px rgba(0,0,0,0.1)" }}>
                          残り {event.capacity}枠
                        </span>
                      </div>
                    )}
                    {event.banner_url ? (
                      // eslint-disable-next-line @next/next/no-img-element
                      <img src={event.banner_url} alt={event.title} style={{ width: "100%", height: "100%", objectFit: "cover" }} />
                    ) : (
                      <div style={{ width: "100%", height: "100%", display: "flex", alignItems: "center", justifyContent: "center", color: "#ccc", fontSize: "0.9rem" }}>NO IMAGE</div>
                    )}
                  </div>
                  <div style={{ padding: "16px", flex: 1, display: "flex", flexDirection: "column", width: "100%" }}>
                    <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: "8px" }}>

                  <div style={{ marginBottom: "8px" }}>
                    {renderEventSchedule(event)}
                  </div>

                  <div style={{ fontSize: "0.8rem", color: "#ff4757", fontWeight: "bold", display: "flex", alignItems: "center", gap: "4px" }}>
                        <span>♥</span> {event.likesCount}
                      </div>
                    </div>
                    <h3 style={{ fontSize: "1.1rem", fontWeight: "bold", marginBottom: "8px", lineHeight: 1.4 }}>
                      {event.title}
                    </h3>
                    <div className="card-desc" style={{ fontSize: "0.9rem", color: "#666", marginBottom: "16px", display: "-webkit-box", WebkitLineClamp: 2, WebkitBoxOrient: "vertical", overflow: "hidden", flex: 1 }}>
                      {event.description}
                    </div>
                    {viewMode !== "compact" && (
                       <Link href={`/events/${event.id}`} className="btn btn-ghost" style={{ width: "100%", textAlign: "center", marginTop: "auto" }}>詳細を見る</Link>
                    )}
                    {viewMode === "compact" && (
                       <Link href={`/events/${event.id}`} style={{ marginLeft: "auto", color: "var(--accent)", textDecoration: "none", fontWeight: "bold" }}>詳細 &rarr;</Link>
                    )}
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      </main>
      <style jsx>{`
        .filter-row { display: flex; align-items: flex-start; gap: 16px; }
        .filter-label { font-weight: bold; font-size: 0.9rem; color: #666; width: 60px; padding-top: 6px; flex-shrink: 0; }
        .filter-options { display: flex; flex-wrap: wrap; gap: 8px; flex: 1; }
        .filter-chip { background: #f5f5f5; border: 1px solid #ddd; padding: 6px 12px; border-radius: 99px; cursor: pointer; font-size: 0.85rem; color: #555; transition: all 0.2s; }
        .filter-chip:hover { background: #eaeaea; }
        .filter-chip.active { background: var(--accent); color: #fff; border-color: var(--accent); }
        .sort-select { padding: 8px 12px; border-radius: 8px; border: 1px solid #ddd; background: #fff; font-size: 0.9rem; cursor: pointer; outline: none; }
        .hover-up { transition: transform 0.2s, box-shadow 0.2s; }
        .hover-up:hover { transform: translateY(-4px); box-shadow: 0 10px 20px rgba(0,0,0,0.1); }
        @media (max-width: 600px) { .filter-row { flex-direction: column; gap: 8px; } .filter-label { width: auto; padding-top: 0; } }
      `}</style>
    </>
  );
}


----------------------------------------
### FILE: page.tsx ###
----------------------------------------
"use client";

import { useState, useEffect } from "react";
import { supabase } from "@/lib/supabase";
import { useRouter } from "next/navigation";
import toast from "react-hot-toast";

export default function FeedbackPage() {
  const router = useRouter();
  const [user, setUser] = useState<any>(null);
  const [loading, setLoading] = useState(true);
  
  // ステップ管理 (1:入力, 2:確認, 3:完了)
  const [step, setStep] = useState(1);
  const [isSubmitting, setIsSubmitting] = useState(false);

  // フォームデータ
  const [category, setCategory] = useState("機能リクエスト");
  const [content, setContent] = useState("");
  const [pageUrl, setPageUrl] = useState("");

  useEffect(() => {
    const init = async () => {
      // 1. ログインチェック
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        // ログインしていなければログイン画面へ飛ばす（またはトップへ）
        router.push("/login");
        return;
      }
      setUser(user);

      // 2. 直前のURLを取得（リファラーがあれば。なければ今のURL）
      setPageUrl(document.referrer || window.location.href);
      
      setLoading(false);
    };
    init();
  }, [router]);

const handleSubmit = async () => {
    setIsSubmitting(true);
    try {
      // ★修正: 直接Supabaseではなく、自作APIを呼ぶ
      const res = await fetch("/api/feedback", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          user_id: user.id,
          category: category,
          content: content,
          page_url: pageUrl,
        }),
      });

      if (!res.ok) {
        const errorData = await res.json();
        throw new Error(errorData.error || "送信に失敗しました");
      }

      setStep(3); // 完了画面へ（ユーザーには成功したように見える）

    } catch (error: any) {
      toast.error("エラーが発生しました: " + error.message);
      setIsSubmitting(false);
    }
  };

  if (loading) return <div style={{ padding: "40px", textAlign: "center" }}>読み込み中...</div>;

  return (
    <div className="container" style={{ maxWidth: "600px", marginTop: "60px", paddingBottom: "80px" }}>
      <h1 className="section-title">フィードバック</h1>
      
      <div className="card">
        {/* === ステップ1: 入力画面 === */}
        {step === 1 && (
          <div>
            <p style={{ color: "var(--muted)", marginBottom: "24px", fontSize: "0.9rem" }}>
              Castketをご利用いただきありがとうございます。<br/>
              サービス改善のため、気になった点やご要望をぜひお聞かせください。
            </p>

            <div style={{ marginBottom: "20px" }}>
              <label className="label-title">カテゴリ</label>
              <select 
                className="input-field" 
                value={category} 
                onChange={(e) => setCategory(e.target.value)}
              >
                <option value="機能リクエスト">✨ 機能リクエスト (こうして欲しい)</option>
                <option value="バグ・不具合">🐛 バグ・不具合の報告</option>
                <option value="感想・応援">📣 感想・応援メッセージ</option>
                <option value="その他">🤔 その他</option>
              </select>
            </div>

            <div style={{ marginBottom: "24px" }}>
              <label className="label-title">内容</label>
              <textarea 
                className="input-field" 
                rows={8} 
                value={content} 
                onChange={(e) => setContent(e.target.value)}
                placeholder="具体的な内容をご記入ください..."
                required
              />
            </div>

            <button 
              className="btn btn-primary" 
              style={{ width: "100%", padding: "14px" }}
              disabled={!content.trim()}
              onClick={() => setStep(2)}
            >
              確認画面へ
            </button>
          </div>
        )}

        {/* === ステップ2: 確認画面 (プレビュー) === */}
        {step === 2 && (
          <div>
            <h2 style={{ fontSize: "1.1rem", marginBottom: "16px", borderBottom: "1px solid #eee", paddingBottom: "8px" }}>送信内容の確認</h2>
            
            <div style={{ marginBottom: "20px" }}>
              <div style={{ fontSize: "0.85rem", color: "var(--muted)" }}>カテゴリ</div>
              <div style={{ fontWeight: "bold", padding: "8px 0" }}>{category}</div>
            </div>

            <div style={{ marginBottom: "24px" }}>
              <div style={{ fontSize: "0.85rem", color: "var(--muted)" }}>内容</div>
              <div style={{ whiteSpace: "pre-wrap", background: "#f9f9f9", padding: "16px", borderRadius: "8px", marginTop: "8px" }}>
                {content}
              </div>
            </div>
            
            <div style={{ display: "grid", gridTemplateColumns: "1fr 2fr", gap: "16px" }}>
              <button 
                className="btn btn-ghost" 
                onClick={() => setStep(1)}
                disabled={isSubmitting}
              >
                修正する
              </button>
              <button 
                className="btn btn-primary" 
                onClick={handleSubmit}
                disabled={isSubmitting}
              >
                {isSubmitting ? "送信中..." : "この内容で送信する"}
              </button>
            </div>
          </div>
        )}

        {/* === ステップ3: 完了画面 === */}
        {step === 3 && (
          <div style={{ textAlign: "center", padding: "40px 0" }}>
            <div style={{ fontSize: "3rem", marginBottom: "16px" }}>📬</div>
            <h2 style={{ fontSize: "1.5rem", marginBottom: "16px" }}>送信完了</h2>
            <p style={{ color: "var(--muted)", marginBottom: "32px" }}>
              貴重なご意見ありがとうございます！<br/>
              今後の開発の参考にさせていただきます。
            </p>
            <button 
              className="btn btn-primary" 
              onClick={() => router.push("/dashboard")}
            >
              ダッシュボードへ戻る
            </button>
          </div>
        )}

      </div>
      
      <style jsx>{`
        .label-title { display: block; margin-bottom: 8px; font-weight: bold; color: #333; }
        .input-field { width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 1rem; background: #fff; }
        .input-field:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 3px rgba(124, 58, 237, 0.1); }
      `}</style>
    </div>
  );
}


----------------------------------------
### FILE: page.tsx ###
----------------------------------------
"use client";

import { useState } from "react";
import Link from "next/link";
import { supabase } from "@/lib/supabase";
import toast from "react-hot-toast";

// ▼ よくある質問のデータ
const FAQ_DATA = [
  {
    id: 1,
    category: "general",
    question: "Castketは無料で使えますか？",
    answer: "はい、基本的な機能はすべて無料でご利用いただけます。イベントの作成、キャストへの応募、プロフィールの公開などに費用はかかりません。"
  },
  {
    id: 2,
    category: "general",
    question: "VRChatのアカウントが必要ですか？",
    answer: "はい、VRChat上でのイベントマッチングを目的としているため、VRChatのアカウントをお持ちであることを前提としています。"
  },
  {
    id: 3,
    category: "cast",
    question: "ポートフォリオ画像が表示されません",
    answer: "プロフィール編集画面から画像をアップロードした後、「保存」ボタンを押し忘れていませんか？ 画像を選択しただけでは保存されませんのでご注意ください。"
  },
  {
    id: 4,
    category: "cast",
    question: "応募したのに返信がきません",
    answer: "主催者の都合により返信が遅れる場合があります。ダッシュボードの「応募したイベント」からステータス（返信待ち・承認・見送り）を確認できます。"
  },
  {
    id: 5,
    category: "organizer",
    question: "イベントの日時を変更したいです",
    answer: "ダッシュボードの「主催イベント」一覧にある「編集」ボタンから、いつでも日時や内容を変更できます。"
  },
  {
    id: 6,
    category: "organizer",
    question: "特定のキャストにオファーを送るには？",
    answer: "キャスト詳細ページの「オファーを送る」ボタンから、ご自身が主催するイベントへの招待を送ることができます。"
  },
];

export default function HelpPage() {
  const [activeCategory, setActiveCategory] = useState<"all" | "general" | "cast" | "organizer">("all");
  const [openItems, setOpenItems] = useState<number[]>([]);

  // お問い合わせフォーム用
  const [contactBody, setContactBody] = useState("");
  const [isSending, setIsSending] = useState(false);

  // アコーディオンの開閉
  const toggleItem = (id: number) => {
    if (openItems.includes(id)) {
      setOpenItems(openItems.filter((item) => item !== id));
    } else {
      setOpenItems([...openItems, id]);
    }
  };

  // フィルタリング
  const filteredFaqs = FAQ_DATA.filter(item => 
    activeCategory === "all" ? true : item.category === activeCategory
  );

  // お問い合わせ送信処理
  const handleSendContact = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!contactBody.trim()) return;
    
    setIsSending(true);
    try {
      const { data: { user } } = await supabase.auth.getUser();

      // 以前作成した feedback API を再利用します
      // (もしAPIのルートが違う場合は適宜修正してください)
      const res = await fetch("/api/feedback", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          user_id: user?.id || null, // ログインしていればIDを送る
          category: "contact",       // カテゴリはお問い合わせ
          content: contactBody,
          page_url: window.location.href
        }),
      });

      if (!res.ok) throw new Error("送信に失敗しました");

      toast.success("お問い合わせありがとうございます！\n内容を確認次第、ご連絡いたします。");
      setContactBody("");
    } catch (error) {
      toast.error("送信中にエラーが発生しました。");
    } finally {
      setIsSending(false);
    }
  };

  return (
    <>
      <header className="site-header">
        <div className="container header-inner">
          <Link href="/" className="logo-wrap" style={{ textDecoration: 'none' }}>
            <div className="logo-mark">C</div>
            <div className="logo-text-block">
              <div className="logo-text-main">Castket</div>
              <div className="logo-text-sub">Help Center</div>
            </div>
          </Link>
          <div className="header-actions">
            <Link href="/" className="btn btn-ghost">トップへ戻る</Link>
          </div>
        </div>
      </header>

      <main className="section section-soft" style={{ minHeight: "100vh" }}>
        <div className="container" style={{ maxWidth: "800px" }}>
          
          <div style={{ textAlign: "center", marginBottom: "40px" }}>
            <h1 className="section-title">ヘルプセンター</h1>
            <p style={{ color: "var(--muted)" }}>
              Castketの使い方や、よくある質問をまとめました。<br/>
              解決しない場合は、ページ下部のフォームよりお問い合わせください。
            </p>
          </div>

          {/* ▼ カテゴリ切り替えタブ ▼ */}
          <div style={{ display: "flex", justifyContent: "center", gap: "8px", marginBottom: "32px", flexWrap: "wrap" }}>
            {[
              { id: "all", label: "すべて" },
              { id: "general", label: "全般" },
              { id: "cast", label: "キャスト向け" },
              { id: "organizer", label: "主催者向け" },
            ].map((tab) => (
              <button
                key={tab.id}
                onClick={() => setActiveCategory(tab.id as any)}
                style={{
                  padding: "8px 20px",
                  borderRadius: "99px",
                  border: activeCategory === tab.id ? "2px solid var(--accent)" : "1px solid #ddd",
                  background: activeCategory === tab.id ? "var(--accent)" : "#fff",
                  color: activeCategory === tab.id ? "#fff" : "#666",
                  fontWeight: "bold",
                  cursor: "pointer",
                  transition: "all 0.2s"
                }}
              >
                {tab.label}
              </button>
            ))}
          </div>

          {/* ▼ FAQリスト (アコーディオン) ▼ */}
          <div style={{ display: "grid", gap: "16px", marginBottom: "60px" }}>
            {filteredFaqs.map((faq) => {
              const isOpen = openItems.includes(faq.id);
              return (
                <div key={faq.id} className="card" style={{ padding: "0", overflow: "hidden", cursor: "pointer" }} onClick={() => toggleItem(faq.id)}>
                  <div style={{ padding: "20px", display: "flex", justifyContent: "space-between", alignItems: "center", background: "#fff" }}>
                    <h3 style={{ fontSize: "1rem", fontWeight: "bold", margin: 0, color: "#333" }}>
                      <span style={{ color: "var(--accent)", marginRight: "8px" }}>Q.</span>
                      {faq.question}
                    </h3>
                    <span style={{ transform: isOpen ? "rotate(180deg)" : "rotate(0deg)", transition: "transform 0.2s", color: "#ccc" }}>▼</span>
                  </div>
                  {isOpen && (
                    <div style={{ padding: "20px", background: "#fdfaff", borderTop: "1px solid #eee", lineHeight: 1.6, color: "#555" }}>
                      {faq.answer}
                    </div>
                  )}
                </div>
              );
            })}
          </div>

          {/* ▼ お問い合わせフォーム ▼ */}
          <div className="card" style={{ padding: "40px" }}>
            <h2 className="section-lead" style={{ marginBottom: "24px" }}>📩 お問い合わせ</h2>
            <p style={{ marginBottom: "24px", color: "var(--muted)", fontSize: "0.9rem" }}>
              機能の要望やバグ報告、その他ご不明な点はこちらからお送りください。<br/>
              ログイン中の場合、あなたのユーザーIDも一緒に送信されます。
            </p>
            <form onSubmit={handleSendContact}>
              <textarea 
                className="input-field" 
                rows={5} 
                required
                placeholder="お問い合わせ内容をご記入ください..."
                value={contactBody}
                onChange={(e) => setContactBody(e.target.value)}
                style={{ width: "100%", padding: "16px", borderRadius: "8px", border: "1px solid #ddd", marginBottom: "16px", fontFamily: "inherit" }}
              />
              <button 
                type="submit" 
                className="btn btn-primary" 
                disabled={isSending || !contactBody}
                style={{ width: "100%", padding: "14px", fontSize: "1.1rem" }}
              >
                {isSending ? "送信中..." : "送信する"}
              </button>
            </form>
          </div>

        </div>
      </main>
    </>
  );
}


----------------------------------------
### FILE: page.tsx ###
----------------------------------------
"use client";

import Link from "next/link";
import Image from "next/image";
import { useState, useEffect } from "react";
import { supabase } from "@/lib/supabase";

export default function HowToPage() {
  const [currentUser, setCurrentUser] = useState<any>(null);
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);
  const [avatarUrl, setAvatarUrl] = useState<string>("");

  // ヘッダー用ロジック (共通化していない場合は各ページに必要です)
  useEffect(() => {
    const fetchData = async () => {
      const { data: { user } } = await supabase.auth.getUser();
      if (user) {
        setCurrentUser(user);
        const { data: profile } = await supabase.from("profiles").select("avatar_url").eq("user_id", user.id).single();
        if (profile) setAvatarUrl(profile.avatar_url);
      }
    };
    fetchData();
  }, []);

  const handleLogout = async () => {
    if (!confirm("ログアウトしますか？")) return;
    await supabase.auth.signOut();
    window.location.href = "/";
  };

  // メニューの中身
  const MenuContent = () => (
    <div style={{ display: "flex", flexDirection: isMobileMenuOpen ? "column" : "row", alignItems: isMobileMenuOpen ? "flex-start" : "center", gap: isMobileMenuOpen ? "20px" : "24px", width: isMobileMenuOpen ? "100%" : "auto" }}>
      <nav style={{ display: "flex", gap: "16px", flexDirection: isMobileMenuOpen ? "column" : "row", width: isMobileMenuOpen ? "100%" : "auto" }}>
        <Link href="/how-to" onClick={() => setIsMobileMenuOpen(false)} style={{ fontSize: "0.9rem", color: "var(--accent)", textDecoration: "none", fontWeight: "bold", padding: isMobileMenuOpen ? "12px 0" : "0", borderBottom: isMobileMenuOpen ? "1px solid #eee" : "none", width: isMobileMenuOpen ? "100%" : "auto" }}>使い方</Link>
        {currentUser && <Link href="/feedback" onClick={() => setIsMobileMenuOpen(false)} style={{ fontSize: "0.9rem", color: "#555", textDecoration: "none", fontWeight: "500", padding: isMobileMenuOpen ? "12px 0" : "0", borderBottom: isMobileMenuOpen ? "1px solid #eee" : "none", width: isMobileMenuOpen ? "100%" : "auto" }}>フィードバック</Link>}
        <Link href="/help" onClick={() => setIsMobileMenuOpen(false)} style={{ fontSize: "0.9rem", color: "#555", textDecoration: "none", fontWeight: "500", padding: isMobileMenuOpen ? "12px 0" : "0", borderBottom: isMobileMenuOpen ? "1px solid #eee" : "none", width: isMobileMenuOpen ? "100%" : "auto" }}>ヘルプ</Link>
      </nav>
      <div style={{ width: isMobileMenuOpen ? "100%" : "auto" }}>
        {currentUser ? (
          <div style={{ display: "flex", alignItems: "center", gap: "16px", flexDirection: isMobileMenuOpen ? "column" : "row", width: isMobileMenuOpen ? "100%" : "auto" }}>
            <Link href="/dashboard" onClick={() => setIsMobileMenuOpen(false)} style={{ display: "flex", alignItems: "center", gap: "12px", textDecoration: "none", color: "inherit", width: isMobileMenuOpen ? "100%" : "auto", padding: isMobileMenuOpen ? "8px 0" : "0" }}>
              <div style={{ width: "40px", height: "40px", borderRadius: "50%", overflow: "hidden", border: "2px solid #fff", boxShadow: "0 2px 8px rgba(0,0,0,0.1)", flexShrink: 0 }}>
                {avatarUrl ? <img src={avatarUrl} alt="My Menu" style={{ width: "100%", height: "100%", objectFit: "cover" }} /> : <div style={{ width: "100%", height: "100%", background: "#ccc", color: "#fff", display: "flex", alignItems: "center", justifyContent: "center", fontSize: "1.2rem" }}>👤</div>}
              </div>
              {isMobileMenuOpen && <span style={{ fontWeight: "bold", fontSize: "1rem" }}>ダッシュボードへ</span>}
            </Link>
            <button onClick={() => { handleLogout(); setIsMobileMenuOpen(false); }} className="btn btn-ghost" style={{ fontSize: "0.9rem", padding: isMobileMenuOpen ? "12px 0" : "8px 16px", textAlign: isMobileMenuOpen ? "left" : "center", width: isMobileMenuOpen ? "100%" : "auto" }}>ログアウト</button>
          </div>
        ) : (
          <Link href="/login" onClick={() => setIsMobileMenuOpen(false)} className="btn btn-primary" style={{ padding: isMobileMenuOpen ? "12px 0" : "8px 20px", width: isMobileMenuOpen ? "100%" : "auto", display: "block", textAlign: "center", marginTop: isMobileMenuOpen ? "16px" : "0", fontWeight: "bold" }}>ログイン / 登録</Link>
        )}
      </div>
    </div>
  );

  return (
    <>
      <header className="site-header">
        <div className="container header-inner" style={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
          <Link href="/" className="logo-wrap" style={{ textDecoration: 'none' }}>
            <div className="logo-mark">C</div>
            <div className="logo-text-block"><div className="logo-text-main">Castket</div><div className="logo-text-sub">How to Use</div></div>
          </Link>
          <div className="pc-menu" style={{ display: "flex", alignItems: "center" }}><MenuContent /></div>
          <button className="mobile-menu-btn" onClick={() => setIsMobileMenuOpen(true)}><span style={{ fontSize: "1.5rem" }}>≡</span></button>
        </div>
      </header>

      {isMobileMenuOpen && (
        <div className="mobile-menu-overlay">
          <div className="mobile-menu-content">
              <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: "32px", borderBottom: "1px solid #eee", paddingBottom: "16px" }}>
                <span style={{ fontWeight: "bold", fontSize: "1.2rem" }}>Menu</span>
                <button onClick={() => setIsMobileMenuOpen(false)} style={{ background: "none", border: "none", fontSize: "1.8rem", cursor: "pointer", padding: "0 8px" }}>×</button>
              </div>
              <MenuContent />
          </div>
        </div>
      )}

      <main className="section section-soft" style={{ minHeight: "100vh" }}>
        <div className="container" style={{ maxWidth: "800px" }}>
          
          <div style={{ textAlign: "center", marginBottom: "60px" }}>
            <h1 className="section-title" style={{ fontSize: "2rem", marginBottom: "16px" }}>Castketの使い方</h1>
            <p style={{ color: "var(--muted)", lineHeight: 1.8 }}>
              Castket（キャスケット）へようこそ！<br/>
              ここでは、VRChatイベントとキャストをつなぐ<br className="mobile-break"/>
              新しいプラットフォームの活用方法をご紹介します。
            </p>
          </div>

          <div className="card" style={{ padding: "0", overflow: "hidden", marginBottom: "60px", boxShadow: "0 8px 30px rgba(0,0,0,0.1)" }}>
             <Image 
               src="/images/howto.jpg" 
               alt="3ステップでわかるCastketの使い方" 
               width={1200} 
               height={675} 
               style={{ width: "100%", height: "auto" }} 
               priority
             />
          </div>

          <div style={{ display: "grid", gap: "40px" }}>
            <section className="card" style={{ display: "flex", gap: "24px", flexDirection: "column" }}>
              <div style={{ display: "flex", alignItems: "center", gap: "12px", borderBottom: "2px solid var(--accent)", paddingBottom: "12px" }}>
                <span style={{ fontSize: "2rem" }}>🔍</span>
                <h2 style={{ fontSize: "1.5rem", fontWeight: "bold", color: "var(--accent)", margin: 0 }}>1. 見つける</h2>
              </div>
              <div>
                <p style={{ lineHeight: 1.8, marginBottom: "16px" }}>
                  まずは気になるイベントや、魅力的なキャストを探してみましょう。<br/>
                  「ロール（役割）」や「プレイスタイル」で絞り込んで、あなたのイベントにぴったりのパートナーを見つけることができます。
                </p>
                <div style={{ display: "flex", gap: "12px" }}>
                  <Link href="/events" className="btn btn-ghost">イベント一覧へ</Link>
                  <Link href="/casts" className="btn btn-ghost">キャスト一覧へ</Link>
                </div>
              </div>
            </section>

            <section className="card" style={{ display: "flex", gap: "24px", flexDirection: "column" }}>
              <div style={{ display: "flex", alignItems: "center", gap: "12px", borderBottom: "2px solid var(--accent)", paddingBottom: "12px" }}>
                <span style={{ fontSize: "2rem" }}>🤝</span>
                <h2 style={{ fontSize: "1.5rem", fontWeight: "bold", color: "var(--accent)", margin: 0 }}>2. つながる</h2>
              </div>
              <div>
                <p style={{ lineHeight: 1.8 }}>
                  詳細ページにある「応募する」ボタンや「オファーを送る」ボタンから、相手にメッセージを送りましょう。<br/>
                  やり取りの状況はダッシュボードでいつでも確認できます。「承諾」されればマッチング成立です！
                </p>
              </div>
            </section>

            <section className="card" style={{ display: "flex", gap: "24px", flexDirection: "column" }}>
              <div style={{ display: "flex", alignItems: "center", gap: "12px", borderBottom: "2px solid var(--accent)", paddingBottom: "12px" }}>
                <span style={{ fontSize: "2rem" }}>🎉</span>
                <h2 style={{ fontSize: "1.5rem", fontWeight: "bold", color: "var(--accent)", margin: 0 }}>3. 創り出す</h2>
              </div>
              <div>
                <p style={{ lineHeight: 1.8, marginBottom: "16px" }}>
                  マッチングしたメンバーと一緒に、最高のVRChatイベントを作り上げましょう。<br/>
                  イベント終了後は、プロフィールに活動写真を追加して、次のチャンスにつなげることもできます。
                </p>
                <Link href="/login" className="btn btn-primary" style={{ display: "inline-block", padding: "12px 32px" }}>さっそく始める</Link>
              </div>
            </section>
          </div>

        </div>
      </main>
      
      <style jsx>{`
        .mobile-menu-btn { display: none; background: none; border: none; cursor: pointer; color: #333; }
        .mobile-menu-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999; }
        .mobile-menu-content { position: absolute; top: 0; right: 0; width: 85%; max-width: 320px; height: 100%; background: #fff; padding: 24px; box-shadow: -4px 0 10px rgba(0,0,0,0.1); display: flex; flexDirection: column; }
        @media (max-width: 768px) {
          .pc-menu { display: none !important; }
          .mobile-menu-btn { display: block !important; }
          .mobile-break { display: block; }
        }
        @media (min-width: 769px) { .mobile-break { display: none; } }
      `}</style>
    </>
  );
}


----------------------------------------
### FILE: page.tsx ###
----------------------------------------
"use client";

import { useState } from "react";
import { supabase } from "@/lib/supabase";
import { useRouter } from "next/navigation";

export default function LoginPage() {
  const router = useRouter();
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [loading, setLoading] = useState(false);
  
  // モード管理: "login" | "signup" | "reset"
  const [mode, setMode] = useState<"login" | "signup" | "reset">("login");
  
  const [message, setMessage] = useState("");

  // 認証処理 (ログイン / 登録)
  const handleAuth = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setMessage("");

    try {
      if (mode === "signup") {
        // 新規登録
        const { error } = await supabase.auth.signUp({
          email,
          password,
        });
        if (error) throw error;
        setMessage("登録が完了しました！自動的にログインします...");
        setTimeout(() => {
          router.push("/dashboard");
          router.refresh();
        }, 1500);

      } else {
        // ログイン
        const { error } = await supabase.auth.signInWithPassword({
          email,
          password,
        });
        if (error) throw error;
        setMessage("ログイン成功！");
        router.push("/dashboard");
        router.refresh();
      }
    } catch (error: any) {
      setMessage(`エラー: ${error.message}`);
    } finally {
      setLoading(false);
    }
  };

  // パスワードリセットメール送信処理
  const handleResetPassword = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setMessage("");

    try {
      // URLは、後で作る「パスワード変更画面」への経由地です
      const { error } = await supabase.auth.resetPasswordForEmail(email, {
        redirectTo: `${window.location.origin}/update-password`,
      });
      
      if (error) throw error;
      setMessage("パスワード再設定メールを送信しました。メールボックスを確認してください。");
      
    } catch (error: any) {      setMessage(`エラー: ${error.message}`);
    } finally {
      setLoading(false);
    }
  };

  // タイトルの切り替え
  const getTitle = () => {
    if (mode === "signup") return "アカウント登録";
    if (mode === "reset") return "パスワード再設定";
    return "ログイン";
  };

  return (
    <div
      style={{
        minHeight: "100vh",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        background: "var(--bg)",
      }}
    >
      <div className="card" style={{ width: "100%", maxWidth: "400px" }}>
        <div style={{ textAlign: "center", marginBottom: "24px" }}>
          <div
            className="logo-mark"
            style={{ margin: "0 auto 12px", width: "48px", height: "48px" }}
          >
            C
          </div>
          <h1 className="card-title" style={{ fontSize: "1.5rem" }}>
            {getTitle()}
          </h1>
          <p className="card-text">
            {mode === "signup" && "Castketで新しい物語を始めましょう"}
            {mode === "login" && "おかえりなさい！"}
            {mode === "reset" && "登録したメールアドレスを入力してください"}
          </p>
        </div>

        {/* --- フォームエリア --- */}
        <form onSubmit={mode === "reset" ? handleResetPassword : handleAuth} style={{ display: "grid", gap: "16px" }}>
          
          {/* メールアドレス (全モードで共通) */}
          <div>
            <label style={{ display: "block", marginBottom: "6px", fontSize: "0.85rem", color: "var(--muted)" }}>
              メールアドレス
            </label>
            <input
              type="email"
              required
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              style={{
                width: "100%", padding: "10px", borderRadius: "8px",
                border: "1px solid var(--border)", outline: "none",
              }}
              placeholder="name@example.com"
            />
          </div>

          {/* パスワード (リセットモード以外で表示) */}
          {mode !== "reset" && (
            <div>
              <div style={{display: "flex", justifyContent: "space-between", marginBottom: "6px"}}>
                <label style={{ fontSize: "0.85rem", color: "var(--muted)" }}>
                  パスワード
                </label>
                {/* ログインモードの時だけ「忘れた場合」を表示 */}
                {mode === "login" && (
                  <button
                    type="button"
                    onClick={() => { setMode("reset"); setMessage(""); }}
                    style={{ background: "none", border: "none", color: "var(--accent)", fontSize: "0.8rem", cursor: "pointer" }}
                  >
                    パスワードを忘れた場合
                  </button>
                )}
              </div>
              <input
                type="password"
                required
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                style={{
                  width: "100%", padding: "10px", borderRadius: "8px",
                  border: "1px solid var(--border)", outline: "none",
                }}
                placeholder="6文字以上で入力"
              />
            </div>
          )}

          {message && (
            <div
              style={{
                padding: "10px", borderRadius: "8px",
                background: message.includes("エラー") ? "#ffecec" : "#e8fbf6",
                color: message.includes("エラー") ? "#ff4757" : "#00b894",
                fontSize: "0.85rem",
              }}
            >
              {message}
            </div>
          )}

          <button
            type="submit"
            className="btn btn-primary"
            style={{ width: "100%", marginTop: "8px" }}
            disabled={loading}
          >
            {loading ? "処理中..." : mode === "signup" ? "登録してはじめる" : mode === "reset" ? "送信する" : "ログイン"}
          </button>
        </form>

        {/* --- モード切り替えリンク --- */}
        <div style={{ marginTop: "24px", textAlign: "center", fontSize: "0.85rem", color: "var(--muted)" }}>
          {mode === "reset" ? (
            <button
              type="button"
              onClick={() => { setMode("login"); setMessage(""); }}
              style={{ background: "none", border: "none", color: "var(--accent)", cursor: "pointer", fontWeight: "600", textDecoration: "underline" }}
            >
              ログイン画面に戻る
            </button>
          ) : (
            <>
              {mode === "signup" ? "すでにアカウントをお持ちですか？" : "アカウントをお持ちでないですか？"}{" "}
              <button
                type="button"
                onClick={() => { setMode(mode === "signup" ? "login" : "signup"); setMessage(""); }}
                style={{ background: "none", border: "none", color: "var(--accent)", cursor: "pointer", fontWeight: "600", textDecoration: "underline" }}
              >
                {mode === "signup" ? "ログインへ" : "新規登録へ"}
              </button>
            </>
          )}
        </div>
        
        <div style={{marginTop: "16px", textAlign: "center"}}>
            <a href="/" style={{fontSize: "0.8rem", color: "var(--muted)"}}>トップページに戻る</a>
        </div>
      </div>
    </div>
  );
}


----------------------------------------
### FILE: page.tsx ###
----------------------------------------
"use client";

import { useState } from "react";
import { supabase } from "@/lib/supabase";
import { useRouter } from "next/navigation";
import toast from "react-hot-toast";

export default function UpdatePasswordPage() {
  const router = useRouter();
  const [password, setPassword] = useState("");
  const [loading, setLoading] = useState(false);
  const [message, setMessage] = useState("");

  const handleUpdate = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setMessage("");

    try {
      // パスワードを更新する
      const { error } = await supabase.auth.updateUser({
        password: password,
      });

      if (error) throw error;

      toast.success("パスワードを変更しました！");
      router.push("/dashboard");
      router.refresh();

    } catch (error: any) {
      setMessage(`エラー: ${error.message}`);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div style={{ minHeight: "100vh", display: "flex", alignItems: "center", justifyContent: "center", background: "var(--bg)" }}>
      <div className="card" style={{ width: "100%", maxWidth: "400px" }}>
        <h1 className="card-title" style={{ textAlign: "center" }}>新しいパスワードの設定</h1>
        <p className="card-text" style={{ textAlign: "center", marginBottom: "24px" }}>
          新しいパスワードを入力してください。
        </p>

        <form onSubmit={handleUpdate}>
          <div style={{ marginBottom: "16px" }}>
            <label style={{ display: "block", marginBottom: "6px", fontSize: "0.85rem", color: "var(--muted)" }}>
              新しいパスワード
            </label>
            <input
              type="password"
              required
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              placeholder="6文字以上で入力"
              style={{ width: "100%", padding: "10px", borderRadius: "8px", border: "1px solid var(--border)" }}
            />
          </div>

          {message && <div style={{ color: "red", fontSize: "0.85rem", marginBottom: "16px" }}>{message}</div>}

          <button type="submit" className="btn btn-primary" style={{ width: "100%" }} disabled={loading}>
            {loading ? "変更中..." : "パスワードを変更する"}
          </button>
        </form>
      </div>
    </div>
  );
}


----------------------------------------
### FILE: imageCompressor.ts ###
----------------------------------------
// app/utils/imageCompressor.ts

import imageCompression from "browser-image-compression";

// アバター用などの圧縮設定
const defaultOptions = { 
  maxSizeMB: 0.5, 
  maxWidthOrHeight: 500, 
  useWebWorker: true 
};

// ギャラリー用などの圧縮設定
const galleryOptions = { 
  maxSizeMB: 1, 
  maxWidthOrHeight: 1280, 
  useWebWorker: true 
};

export const compressImage = async (file: File, type: "avatar" | "gallery" = "avatar") => {
  const options = type === "gallery" ? galleryOptions : defaultOptions;
  try {
    const compressedFile = await imageCompression(file, options);
    return compressedFile;
  } catch (error) {
    console.error("Compression error:", error);
    throw error;
  }
};


----------------------------------------
### FILE: globals.css ###
----------------------------------------
:root {
  --bg: #f5f6fb;
  --bg-soft: #ffffff;
  --bg-accent: linear-gradient(135deg, #7b6cff, #ff6ec7);
  --accent: #6c5ce7;
  --accent-2: #ff6ec7;
  --accent-3: #00b894;
  --text: #1f2230;
  --muted: #737799;
  --border: #dde0f0;
  --radius-lg: 18px;
  --radius-md: 12px;
  --radius-full: 999px;
  --shadow-soft: 0 10px 35px rgba(15, 25, 58, 0.15);
  --max-width: 1120px;
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  background: radial-gradient(circle at top, #f3e9ff 0%, #f5f6fb 50%, #f5f6fb 100%);
  color: var(--text);
  line-height: 1.6;
}

a {
  color: inherit;
  text-decoration: none;
}

.container {
  width: 100%;
  max-width: var(--max-width);
  margin: 0 auto;
  padding: 0 16px;
}

/* Header */
.site-header {
  position: sticky;
  top: 0;
  z-index: 20;
  backdrop-filter: blur(18px);
  background: rgba(255, 255, 255, 0.9);
  border-bottom: 1px solid rgba(220, 224, 245, 0.9);
}

.header-inner {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 16px;
  gap: 16px;
}

.logo-mark {
  width: 30px;
  height: 30px;
  border-radius: 10px;
  background: radial-gradient(circle at 20% 0%, #ffeaa7 0, transparent 60%),
    radial-gradient(circle at 75% 100%, #ff7675 0, transparent 55%),
    linear-gradient(135deg, #6c5ce7, #00cec9);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.95rem;
  font-weight: 800;
  color: #ffffff;
  margin-right: 8px;
  box-shadow: 0 6px 16px rgba(90, 76, 230, 0.5);
}

.logo-text-main {
  font-weight: 700;
  letter-spacing: 0.06em;
  font-size: 1rem;
}

.logo-text-sub {
  font-size: 0.7rem;
  color: var(--muted);
  margin-top: -2px;
}

.logo-wrap {
  display: flex;
  align-items: center;
  gap: 6px;
}

.logo-text-block {
  display: flex;
  flex-direction: column;
}

.main-nav {
  display: flex;
  align-items: center;
  gap: 16px;
  font-size: 0.88rem;
}

.main-nav a {
  text-decoration: none;
  color: var(--muted);
  padding: 6px 10px;
  border-radius: 999px;
  transition: background 0.2s, color 0.2s;
}

.main-nav a:hover {
  background: rgba(108, 92, 231, 0.08);
  color: var(--accent);
}

.header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
}

.nav-toggle {
  display: none;
  background: none;
  border: none;
  color: var(--text);
  font-size: 1.4rem;
  cursor: pointer;
}

/* Buttons */
.btn {
  border-radius: var(--radius-full);
  padding: 8px 18px;
  border: none;
  cursor: pointer;
  font-size: 0.9rem;
  font-weight: 500;
  transition: transform 0.1s ease, box-shadow 0.1s ease, background 0.2s,
    color 0.2s;
  white-space: nowrap;
}

.btn-primary {
  background-image: var(--bg-accent);
  color: #fff;
  box-shadow: var(--shadow-soft);
}

.btn-primary:hover {
  transform: translateY(-1px);
}

.btn-secondary {
  background: #ffffff;
  border: 1px solid rgba(108, 92, 231, 0.18);
  color: var(--accent);
}

.btn-outline {
  background: transparent;
  border: 1px solid rgba(116, 125, 140, 0.4);
  color: var(--text);
}

.btn-ghost {
  background: transparent;
  border: 1px solid transparent;
  color: var(--muted);
}

.btn-large {
  padding: 12px 28px;
  font-size: 1rem;
}

.badge {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  border-radius: 999px;
  padding: 3px 11px;
  font-size: 0.7rem;
  background: rgba(108, 92, 231, 0.08);
  color: var(--accent);
  margin-bottom: 10px;
  border: 1px solid rgba(108, 92, 231, 0.18);
}

.badge-dot {
  width: 7px;
  height: 7px;
  border-radius: 999px;
  background: #00b894;
  box-shadow: 0 0 6px rgba(0, 184, 148, 0.9);
}

/* Hero */
.hero-section {
  position: relative;
  /* 画面の高さの80%を使ってポスターのように見せる */
  height: 80vh; 
  min-height: 500px;
  max-height: 900px;
  
  /* コンテンツを「左下」に寄せる設定 */
  display: flex;
  align-items: flex-end; 
  justify-content: flex-start;
  text-align: left;
  
  overflow: hidden;
  background: #000; /* 画像読み込み前は黒背景 */
}

.hero-bg-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 1;
}

.hero-bg-slide {
position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-size: cover;
  
  /* ★修正箇所： top ではなく center に変更します */
  /* これで、拡大しても「画像の中心」を維持しようとします */
  background-position: center center; 
  
  opacity: 0;
  transition: opacity 2s ease-in-out;
}
.hero-bg-slide.active {
  opacity: 1;
}

/* グラデーションオーバーレイ：上は透明、下に行くほど白くして文字を読みやすく */
.hero-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(to bottom, rgba(255,255,255,0) 40%, rgba(255,255,255,0.9) 90%, rgba(255,255,255,1) 100%);
  z-index: 2;
  pointer-events: none;
}

.hero-content {
  position: relative;
  z-index: 10;
  width: 100%;
  max-width: 100%;
  margin: 0 auto;
  /* 左下に余白を持たせる */
  padding: 0 60px 80px 60px; 
}

.hero-title {
  font-size: clamp(2rem, 5vw, 3.5rem); /* 画面幅に合わせて大きさを調整 */
  font-weight: 800;
  margin-bottom: 16px;
  color: #333;
  line-height: 1.2;
  /* 文字が見やすいように白縁取り */
  text-shadow: 2px 2px 10px rgba(255,255,255,0.8);
}

.hero-subtitle {
  font-size: 1.1rem;
  color: #444;
  margin-bottom: 32px;
  font-weight: 600;
  text-shadow: 1px 1px 5px rgba(255,255,255,0.8);
  max-width: 600px; /* 横に広がりすぎないように制限 */
}

/* ボタンを横並びにするコンテナ */
.hero-btn-container {
  display: flex;
  gap: 20px;
  flex-wrap: wrap;
  justify-content: flex-start; /* 左寄せ */
}

/* スマホ対応 */
@media (max-width: 768px) {
  .hero-section {
    align-items: flex-end;
    text-align: center; /* スマホは中央揃えの方が見やすい */
  }
  .hero-content {
    padding: 0 20px 80px 20px;
  }
  .hero-btn-container {
    justify-content: center; /* スマホではボタン中央寄せ */
  }
  .hero-subtitle {
    margin-left: auto;
    margin-right: auto;
  }
  /* スマホでは画像の顔が見えなくならないように微調整 */
  .hero-bg-slide {
position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-size: cover;
  /* ★変更点1: 「center top」だと顔が切れることがあるので、「center center」に変更 */
  /* (もし顔が下すぎるなら center 30% など微調整もアリです) */
  background-position: center center; 
  opacity: 0;
  transition: opacity 2s ease-in-out;
}  }
/* Sections */
.section {
  padding: 60px 0;
}

.section-alt {
  background: #ffffff;
}

.section-soft {
  background: #f9f9ff;
}

.section-title {
  font-size: 1.55rem;
  margin-bottom: 8px;
}

.section-lead {
  color: var(--muted);
  margin-bottom: 24px;
  max-width: 640px;
  font-size: 0.94rem;
}

/* About */
.about-grid {
  display: grid;
  grid-template-columns: minmax(0, 1.4fr) minmax(0, 1.4fr);
  gap: 28px;
  align-items: flex-start;
}

.pill-list {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.pill {
  border-radius: 999px;
  border: 1px solid var(--border);
  padding: 5px 11px;
  font-size: 0.78rem;
  color: var(--muted);
  background: #ffffff;
}

.card-grid {
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 18px;
}

.card {
  background: #ffffff;
  border-radius: var(--radius-md);
  padding: 16px 16px 14px;
  border: 1px solid var(--border);
  box-shadow: 0 4px 16px rgba(15, 25, 58, 0.08);
}

.card-title {
  font-size: 1rem;
  margin-bottom: 4px;
}

.card-tag {
  font-size: 0.72rem;
  color: var(--muted);
  margin-bottom: 8px;
}

.card-text {
  font-size: 0.86rem;
  color: var(--muted);
  margin-bottom: 6px;
}

.card-link {
  font-size: 0.82rem;
  color: var(--accent);
  text-decoration: none;
}

/* Features */
.feature-grid {
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 18px;
}

.feature-card {
  background: #ffffff;
  border-radius: var(--radius-md);
  border: 1px solid var(--border);
  padding: 16px 16px 14px;
  font-size: 0.88rem;
  box-shadow: 0 4px 18px rgba(15, 25, 58, 0.08);
}

.feature-label {
  font-size: 0.75rem;
  color: var(--muted);
  margin-bottom: 4px;
}

.feature-title {
  font-size: 1rem;
  margin-bottom: 6px;
  color: var(--accent);
}

.feature-list {
  padding-left: 18px;
  margin: 6px 0 0;
  color: var(--muted);
  font-size: 0.85rem;
}

/* Steps */
.steps {
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 18px;
  margin-bottom: 18px;
}

.step {
  background: #ffffff;
  border-radius: var(--radius-md);
  padding: 16px 16px 14px;
  border: 1px solid var(--border);
  box-shadow: 0 4px 16px rgba(15, 25, 58, 0.06);
}

.step-num {
  display: inline-block;
  padding: 4px 12px;
  border-radius: var(--radius-full);
  background: rgba(108, 92, 231, 0.08);
  font-size: 0.75rem;
  margin-bottom: 6px;
  color: var(--accent);
}

.step-title {
  font-size: 0.98rem;
  margin-bottom: 4px;
}

.step-text {
  font-size: 0.86rem;
  color: var(--muted);
}

.steps-caption {
  font-size: 0.8rem;
  color: var(--muted);
}

/* News */
.news-list {
  list-style: none;
  padding: 0;
  margin: 0;
  border-radius: var(--radius-md);
  border: 1px solid var(--border);
  background: #ffffff;
  font-size: 0.88rem;
  box-shadow: 0 4px 14px rgba(15, 25, 58, 0.06);
}

.news-item {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  align-items: center;
  padding: 11px 14px;
  border-bottom: 1px solid rgba(221, 224, 240, 0.8);
}

.news-item:last-child {
  border-bottom: none;
}

.news-item time {
  font-size: 0.8rem;
  color: var(--muted);
  flex-shrink: 0;
  width: 92px;
}

.news-item a {
  color: var(--text);
  text-decoration: none;
}

.news-tag {
  font-size: 0.7rem;
  color: var(--muted);
  border-radius: 999px;
  border: 1px solid var(--border);
  padding: 2px 7px;
  margin-left: auto;
}

/* FAQ */
.faq-list {
  display: grid;
  grid-template-columns: minmax(0, 1.1fr) minmax(0, 1.1fr);
  gap: 16px;
  font-size: 0.88rem;
}

.faq-item {
  background: #ffffff;
  border-radius: var(--radius-md);
  border: 1px solid var(--border);
  padding: 12px 14px 11px;
  box-shadow: 0 4px 16px rgba(15, 25, 58, 0.06);
}

.faq-q {
  font-size: 0.86rem;
  font-weight: 600;
  margin-bottom: 4px;
}

.faq-a {
  color: var(--muted);
  font-size: 0.84rem;
}

/* Contact */
.contact-block {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 24px;
  flex-wrap: wrap;
  background: #ffffff;
  border-radius: var(--radius-lg);
  border: 1px solid var(--border);
  padding: 24px 20px;
  box-shadow: 0 8px 24px rgba(15, 25, 58, 0.1);
}

/* Footer */
.site-footer {
  border-top: 1px solid rgba(221, 224, 240, 0.9);
  padding: 28px 0 24px;
  background: #ffffff;
  font-size: 0.84rem;
}

.footer-inner {
  display: grid;
  grid-template-columns: minmax(0, 2fr) repeat(3, minmax(0, 1.2fr));
  gap: 22px;
}

.footer-block h3 {
  font-size: 0.9rem;
  margin-bottom: 8px;
}

.footer-block a {
  display: block;
  color: var(--muted);
  text-decoration: none;
  margin-bottom: 4px;
}

.footer-copy {
  color: var(--muted);
  margin-top: 10px;
}

.footer-mini {
  margin-top: 6px;
  color: var(--muted);
  font-size: 0.78rem;
}

/* Responsive */
@media (max-width: 960px) {
  .hero-inner {
    grid-template-columns: minmax(0, 1fr);
  }
  .hero-visual {
    justify-content: flex-start;
  }
  .about-grid {
    grid-template-columns: minmax(0, 1fr);
  }
  .card-grid,
  .feature-grid,
  .steps {
    grid-template-columns: minmax(0, 1fr);
  }
  .faq-list {
    grid-template-columns: minmax(0, 1fr);
  }
  .footer-inner {
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }
}

@media (max-width: 768px) {
  .header-inner {
    padding-inline: 10px;
  }

  .main-nav,
  .header-actions {
    display: none;
  }

  .main-nav.is-open,
  .header-actions.is-open {
    display: flex;
  }

  .main-nav {
    position: absolute;
    top: 50px;
    left: 0;
    right: 0;
    flex-direction: column;
    background: #ffffff;
    padding: 10px 16px;
    border-bottom: 1px solid rgba(221, 224, 240, 0.9);
  }

  .header-actions {
    position: absolute;
    top: 50px;
    right: 16px;
    margin-top: 112px;
    flex-direction: column;
    align-items: flex-end;
  }

  .nav-toggle {
    display: block;
  }

  .contact-block {
    flex-direction: column;
    align-items: flex-start;
  }

  .footer-inner {
    grid-template-columns: minmax(0, 1fr);
  }
}

/* ▼▼▼ トップページのボタン用デザイン（ここを追加） ▼▼▼ */
.hero-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 14px 32px;
  border-radius: 99px;
  font-weight: bold;
  font-size: 1.1rem;
  text-decoration: none;
  transition: all 0.3s ease;
  box-shadow: 0 4px 6px rgba(0,0,0,0.1);
  margin: 0 8px; /* ボタン同士の間隔 */
}

/* ホバー時の動き（共通） */
.hero-btn:hover {
  transform: translateY(-4px); /* ふわっと浮く */
  box-shadow: 0 8px 15px rgba(0,0,0,0.15);
}

/* イベントを探すボタン（紫） */
.btn-event {
  background: #7c3aed; /* メインカラー */
  color: #fff;
  border: 2px solid #7c3aed;
}
.btn-event:hover {
  background: #6d28d9;
  border-color: #6d28d9;
}

/* キャストを探すボタン（白×ピンク） */
.btn-cast {
  background: #5dec47ff;
  color: #fff;
  border: 2px solid #5dec47ff;
}
.btn-cast:hover {
  background: #1dd42f; /* 薄いピンク */
}

/* ▼▼▼ カードのホバーアニメーション（ここを追加） ▼▼▼ */
.hover-up {
  transition: transform 0.2s ease, box-shadow 0.2s ease; /* 0.2秒かけて変化 */
}

.hover-up:hover {
  transform: translateY(-4px); /* 4ピクセル上に浮く */
  box-shadow: 0 10px 20px rgba(0,0,0,0.12); /* 影を落として浮遊感を出す */
}

/* 1. グラデーション文字（「舞台」用） */
        .text-gradient {
          background: linear-gradient(135deg, #7c3aed 0%, #ff4757 100%);
          -webkit-background-clip: text;
          -webkit-text-fill-color: transparent;
          font-weight: 900; /* さらに太く */
          display: inline-block; /* グラデーションを綺麗に見せるため */
        }

        /* 2. 下線ハイライト（「イベント共創...」用） */
        .text-highlight {
          position: relative;
          font-weight: bold;
          color: #333;
          z-index: 1;
        }
        .text-highlight::after {
          /* マーカーペンで引いたような線 */
          content: "";
          position: absolute;
          bottom: 2px;
          left: -4px;
          right: -4px;
          height: 8px;
          background: rgba(255, 71, 87, 0.2); /* 薄いピンク */
          z-index: -1;
          border-radius: 4px;
        }

        /* 3. 出現アニメーション（下からフワッ） */
        .animate-fade-up {
          opacity: 0;
          animation: fadeInUp 0.8s ease-out forwards;
        }
        
        .delay-200 { animation-delay: 0.6s; } /* サブタイトルは少し遅れて */
        .delay-400 { animation-delay: 1.0s; } /* ボタンはさらに遅れて */

        @keyframes fadeInUp {
          from {
            opacity: 0;
            transform: translateY(20px);
          }
          to {
            opacity: 1;
            transform: translateY(0);
          }

        }
        /* スリムなスタッツカード */
.stat-card {
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 16px 24px;
  border-radius: 12px;
  background: #fff;
  border: 1px solid #eaeaea;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
  min-height: 80px; /*高さを揃える*/
}

.stat-icon {
  font-size: 2rem;
}

/* クイックアクションのグリッド配置 */
.menu-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
  gap: 16px;
}

/* 浮き上がるメニューカード */
.menu-card {
  display: flex;
  align-items: center;
  gap: 16px;
  background: #fff;
  border: 1px solid #ddd;
  border-radius: 12px;
  padding: 24px;
  text-decoration: none;
  color: #333;
  transition: all 0.2s ease;
  box-shadow: 0 4px 6px rgba(0,0,0,0.02);
}

/* ホバー時の動き（フワッと持ち上がる） */
.menu-card:hover {
  transform: translateY(-5px);
  box-shadow: 0 12px 24px rgba(0,0,0,0.1);
  border-color: #7c3aed; /* アクセントカラー */
}

.menu-icon {
  font-size: 2.2rem;
}
.menu-title {
  font-weight: bold;
  font-size: 1.05rem;
  margin-bottom: 4px;
}
.menu-desc {
  font-size: 0.8rem;
  color: #777; /* primaryの時はCSSで白く上書きされます */
}

/* ▼▼▼ イベント一覧の表示切り替え用スタイル ▼▼▼ */

/* ビュー切り替えボタンのエリア */
.view-toggle-area {
  display: flex;
  justify-content: flex-end;
  margin-bottom: 16px;
  gap: 8px;
}

.view-btn {
  background: #fff;
  border: 1px solid #ddd;
  padding: 8px 12px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 1.2rem;
  transition: all 0.2s;
  color: #888;
}

.view-btn:hover { background: #f9f9f9; color: #333; }
.view-btn.active {
  background: #f3e8ff; /* 薄い紫 */
  color: #7c3aed;
  border-color: #7c3aed;
}

/* === リスト表示（横長カード） === */
.event-container.list-view {
  grid-template-columns: 1fr !important; /* 強制的に1列にする */
}

.event-card.list-view {
  display: flex;
  flex-direction: row; /* 横並びにする */
  align-items: center;
  gap: 16px;
  padding: 12px;
  min-height: 120px;
}

/* リスト表示の時の画像エリア */
.event-card.list-view .card-image {
  width: 120px;      /* 固定幅 */
  height: 90px;      /* 固定高さ */
  flex-shrink: 0;    /* 縮まないようにする */
  border-radius: 8px;
  margin-bottom: 0;  /* 下のマージンを消す */
}

/* === テキスト表示（画像なし・極小） === */
.event-container.compact-view {
  grid-template-columns: 1fr !important;
  gap: 8px;
}

.event-card.compact-view {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  padding: 12px 16px;
  min-height: auto;
}

.event-card.compact-view .card-image {
  display: none; /* 画像を消す */
}

.event-card.compact-view .card-desc {
  display: none; /* 長い説明文も消す */
}

/* =========================================
   エラーページ用スタイル
   ========================================= */

.error-container {
  padding: 40px;
  text-align: center;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: var(--bg);
}

.error-title {
  font-size: 1.5rem;
  margin-bottom: 24px;
  color: #ff4757;
  font-weight: bold;
}

.error-text {
  color: var(--muted);
  margin-bottom: 32px;
  line-height: 1.6;
}

/* 画像のラッパー：ここで光彩（ドロップシャドウ）をつける */
.image-wrapper {
  margin-bottom: 24px;
  /* 白い光彩をつけて、神々しく（？）する */
  filter: drop-shadow(0 0 15px rgba(255, 255, 255, 0.8));
}

/* 画像本体のスタイル */
.soft-circle-image {
  /* ▼ここが重要！画像を潰さない設定▼ */
  width: 250px;       /* 枠の幅 */
  height: 250px;      /* 枠の高さ（正方形にする） */
  object-fit: cover;  /* 画像の比率を維持したまま、枠いっぱいに広げる（はみ出た分はカット） */
  
  border-radius: 50%; /* 丸くする */
  
  /* 周りをぼんやりさせるマスク */
  -webkit-mask-image: radial-gradient(circle at center, black 50%, transparent 85%);
  mask-image: radial-gradient(circle at center, black 50%, transparent 85%);
}

/* アニメーション定義 */
.fade-in {
  animation: fadeIn 1s ease-out forwards; /* forwardsで最後のアニメーション状態を維持 */
  opacity: 0; /* 最初は隠しておく */
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}


----------------------------------------
### FILE: layout.tsx ###
----------------------------------------
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { Toaster } from "react-hot-toast";
import NotificationListener from "@/components/NotificationListener";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Castket |　VRChatイベントプラットフォーム",
  description: "VRChatのイベント主催者とキャストをつなぐマッチングプラットフォーム",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <NotificationListener />
        <Toaster position="bottom-right" reverseOrder={false} />
        {children}
      </body>
    </html>
  );
}



----------------------------------------
### FILE: page.tsx ###
----------------------------------------
"use client";

import { useEffect, useState } from "react";
import { supabase } from "@/lib/supabase";
import Link from "next/link";
// Imageコンポーネントは不要になったので削除してもOKですが、EventCardなどで使うなら残しておいてください
import { useRouter } from "next/navigation";
import { ROLE_OPTIONS } from "@/lib/constants";

// スライドショー画像
const HERO_IMAGES = [
  "https://pub-0880e8d61d8d40aeb4faefabd6b5ed19.r2.dev/Top_Banner/G4-wCXbbIAA8VLJ.jpg",
  "https://pub-0880e8d61d8d40aeb4faefabd6b5ed19.r2.dev/Top_Banner/VRChat_2024-09-29_14-43-36.240_1920x1080.jpg",
  "https://pub-0880e8d61d8d40aeb4faefabd6b5ed19.r2.dev/Top_Banner/VRChat_2024-11-01_23-35-35.442_3840x2160.jpg",
  "https://pub-0880e8d61d8d40aeb4faefabd6b5ed19.r2.dev/Top_Banner/VRChat_2024-11-17_01-09-52.563_3840x2160.jpg",
  "https://pub-0880e8d61d8d40aeb4faefabd6b5ed19.r2.dev/Top_Banner/VRChat_2025-11-16_00-03-00.620_3840x2160.jpg",
  "https://pub-0880e8d61d8d40aeb4faefabd6b5ed19.r2.dev/Top_Banner/VRChat_2025-05-25_04-14-19.218_3840x2160.jpg",
  "https://pub-0880e8d61d8d40aeb4faefabd6b5ed19.r2.dev/Top_Banner/VRChat_2025-10-15_23-49-35.528_2560x1440.jpg",
];

export default function Home() {
  const router = useRouter();
  
  const [popularCasts, setPopularCasts] = useState<any[]>([]); 
  const [newCasts, setNewCasts] = useState<any[]>([]);        
  const [featuredEvents, setFeaturedEvents] = useState<any[]>([]); 
  const [upcomingEvents, setUpcomingEvents] = useState<any[]>([]); 
  const [newsList, setNewsList] = useState<any[]>([]);
  
  const [currentHeroIndex, setCurrentHeroIndex] = useState(0);
  const [currentUser, setCurrentUser] = useState<any>(null);
  const [avatarUrl, setAvatarUrl] = useState<string>("");
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);

  const getRoleLabel = (value: string | null) => {
    if (!value) return "";
    const found = ROLE_OPTIONS.find((opt) => opt.value === value);
    return found ? found.label : value;
  };

  const pickRandom = (array: any[], count: number) => {
    const shuffled = [...array].sort(() => 0.5 - Math.random());
    return shuffled.slice(0, count);
  };

  const getNextEventDate = (event: any, today: string) => {
    if (event.schedule_type === "one_time") return event.event_date || "9999-99-99";
    if (event.schedule_type === "irregular" && event.irregular_dates) {
      const futureDates = event.irregular_dates.filter((d: string) => d >= today).sort();
      return futureDates[0] || "9999-99-99";
    }
    if (event.schedule_type === "weekly") return today; 
    return "9999-99-99";
  };

  const handleLogout = async () => {
    if (!confirm("ログアウトしますか？")) return;
    await supabase.auth.signOut();
    window.location.reload(); 
  };

  useEffect(() => {
    const timer = setInterval(() => {
      setCurrentHeroIndex((prev) => (prev + 1) % HERO_IMAGES.length);
    }, 5000);

    const fetchData = async () => {
      const today = new Date();
      const todayStr = today.toISOString().split("T")[0];
      const periodDate = new Date();
      periodDate.setDate(today.getDate() - 30);
      const periodIso = periodDate.toISOString();

      const { data: { user } } = await supabase.auth.getUser();
      if (user) {
        setCurrentUser(user);
        const { data: profile } = await supabase.from("profiles").select("avatar_url").eq("user_id", user.id).single();
        if (profile) setAvatarUrl(profile.avatar_url);
      }

      const { data: newsData } = await supabase.from("news").select("*").order("created_at", { ascending: false }).limit(3);
      if (newsData) setNewsList(newsData);

      const { data: eventsData } = await supabase.from("events").select("*").order("created_at", { ascending: false });
      const { data: eventLikes } = await supabase.from("likes").select("event_id").gte("created_at", periodIso);
      const eventLikeCounts: { [key: string]: number } = {};
      if (eventLikes) {
        eventLikes.forEach((like) => { eventLikeCounts[like.event_id] = (eventLikeCounts[like.event_id] || 0) + 1; });
      }

      if (eventsData) {
        const activeEvents = eventsData.filter((event) => {
          if (event.schedule_type === "one_time") return event.event_date >= todayStr;
          if (event.schedule_type === "irregular" && event.irregular_dates) return event.irregular_dates.some((d: string) => d >= todayStr);
          return true;
        });

        const featuredEventPool = [...activeEvents].sort((a, b) => (eventLikeCounts[b.id] || 0) - (eventLikeCounts[a.id] || 0)).slice(0, 20);
        setFeaturedEvents(pickRandom(featuredEventPool, 4));

        const sortedByDate = [...activeEvents].sort((a, b) => {
          const dateA = getNextEventDate(a, todayStr);
          const dateB = getNextEventDate(b, todayStr);
          return dateA < dateB ? -1 : dateA > dateB ? 1 : 0;
        });
        setUpcomingEvents(sortedByDate.slice(0, 4));
      }

      const { data: profilesData } = await supabase.from("profiles").select("*").order("created_at", { ascending: false });
      const { data: profileLikes } = await supabase.from("profile_likes").select("target_cast_id").gte("created_at", periodIso);
      const castLikeCounts: { [key: string]: number } = {};
      if (profileLikes) {
        profileLikes.forEach((like) => { castLikeCounts[like.target_cast_id] = (castLikeCounts[like.target_cast_id] || 0) + 1; });
      }

      if (profilesData) {
        setNewCasts(pickRandom(profilesData.slice(0, 20), 4));
        const popularSorted = [...profilesData].sort((a, b) => (castLikeCounts[b.user_id] || 0) - (castLikeCounts[a.user_id] || 0));
        setPopularCasts(pickRandom(popularSorted.slice(0, 20), 4));
      }
    };

    fetchData();
    return () => clearInterval(timer);
  }, []);

  const CastCard = ({ cast }: { cast: any }) => (
    <Link href={`/casts/${cast.user_id}`} style={{ textDecoration: "none", color: "inherit" }}>
      <div className="card hover-up" style={{ padding: "16px", display: "flex", alignItems: "center", gap: "12px" }}>
        <div style={{ width: "50px", height: "50px", borderRadius: "50%", overflow: "hidden", background: "#eee", flexShrink: 0 }}>
          {cast.avatar_url ? <img src={cast.avatar_url} alt="" style={{ width: "100%", height: "100%", objectFit: "cover" }} /> : <div style={{ width: "100%", height: "100%", display: "flex", alignItems: "center", justifyContent: "center", color: "#ccc" }}>?</div>}
        </div>
        <div style={{ overflow: "hidden" }}>
          <div style={{ fontWeight: "bold", fontSize: "0.95rem", whiteSpace: "nowrap", overflow: "hidden", textOverflow: "ellipsis" }}>{cast.display_name}</div>
          <div style={{ fontSize: "0.75rem", color: "var(--muted)" }}>{getRoleLabel(cast.role)}</div>
        </div>
      </div>
    </Link>
  );

  const EventCard = ({ event }: { event: any }) => (
    <Link href={`/events/${event.id}`} style={{ textDecoration: "none", color: "inherit" }}>
      <article className="card hover-up" style={{ padding: "0", overflow: "hidden", height: "100%", display: "flex", flexDirection: "column" }}>
        <div style={{ width: "100%", aspectRatio: "16/9", background: "#eee", position: "relative" }}>
          {event.banner_url ? <img src={event.banner_url} alt={event.title} style={{ width: "100%", height: "100%", objectFit: "cover" }} /> : <div style={{ width: "100%", height: "100%", display: "flex", alignItems: "center", justifyContent: "center", color: "#aaa", fontSize: "0.8rem" }}>NO IMAGE</div>}
          {event.requirements && <div style={{ position: "absolute", bottom: "0", left: "0", right: "0", background: "rgba(124, 58, 237, 0.9)", color: "#fff", padding: "2px 8px", fontSize: "0.7rem", fontWeight: "bold", textAlign: "center" }}>募集中</div>}
        </div>
        <div style={{ padding: "12px", flex: 1 }}>
          <h3 style={{ fontSize: "0.95rem", fontWeight: "bold", marginBottom: "4px", lineHeight: 1.4 }}>{event.title}</h3>
          <div style={{ fontSize: "0.8rem", color: "var(--muted)" }}>{event.schedule_type === "one_time" ? event.event_date : "定期/不定期"}</div>
        </div>
      </article>
    </Link>
  );

  const MenuContent = () => (
    <div style={{ 
      display: "flex", 
      flexDirection: isMobileMenuOpen ? "column" : "row", 
      alignItems: isMobileMenuOpen ? "flex-start" : "center",
      width: isMobileMenuOpen ? "100%" : "auto",
      gap: isMobileMenuOpen ? "20px" : "24px"
    }}>
      <nav style={{ display: "flex", gap: "16px", flexDirection: isMobileMenuOpen ? "column" : "row", width: isMobileMenuOpen ? "100%" : "auto" }}>
        {/* ▼▼▼ 追加: 使い方ページへのリンク ▼▼▼ */}
        <Link href="/how-to" onClick={() => setIsMobileMenuOpen(false)} style={{ fontSize: "0.9rem", color: "#555", textDecoration: "none", fontWeight: "500", padding: isMobileMenuOpen ? "12px 0" : "0", borderBottom: isMobileMenuOpen ? "1px solid #eee" : "none", width: isMobileMenuOpen ? "100%" : "auto" }}>
          使い方
        </Link>
        {/* ▲▲▲ 追加ここまで ▲▲▲ */}

        {currentUser && (
          <Link href="/feedback" onClick={() => setIsMobileMenuOpen(false)} style={{ fontSize: "0.9rem", color: "#555", textDecoration: "none", fontWeight: "500", padding: isMobileMenuOpen ? "12px 0" : "0", borderBottom: isMobileMenuOpen ? "1px solid #eee" : "none", width: isMobileMenuOpen ? "100%" : "auto" }}>
            フィードバック
          </Link>
        )}
        <Link href="/help" onClick={() => setIsMobileMenuOpen(false)} style={{ fontSize: "0.9rem", color: "#555", textDecoration: "none", fontWeight: "500", padding: isMobileMenuOpen ? "12px 0" : "0", borderBottom: isMobileMenuOpen ? "1px solid #eee" : "none", width: isMobileMenuOpen ? "100%" : "auto" }}>ヘルプ</Link>
      </nav>

      <div style={{ width: isMobileMenuOpen ? "100%" : "auto" }}>
        {currentUser ? (
          <div style={{ 
            display: "flex", 
            alignItems: "center", 
            gap: "16px", 
            flexDirection: isMobileMenuOpen ? "column" : "row", 
            width: isMobileMenuOpen ? "100%" : "auto" 
          }}>
            <Link href="/dashboard" title="ダッシュボードへ" onClick={() => setIsMobileMenuOpen(false)} style={{ display: "flex", alignItems: "center", gap: "12px", textDecoration: "none", color: "inherit", width: isMobileMenuOpen ? "100%" : "auto", padding: isMobileMenuOpen ? "8px 0" : "0" }}>
              <div 
                className="header-avatar-container"
                style={{ width: "40px", height: "40px", borderRadius: "50%", overflow: "hidden", border: "2px solid #fff", boxShadow: "0 2px 8px rgba(0,0,0,0.1)", flexShrink: 0, position: "relative" }}
              >
                {avatarUrl ? (
                  // eslint-disable-next-line @next/next/no-img-element
                  <img src={avatarUrl} alt="My Menu" style={{ width: "100%", height: "100%", objectFit: "cover" }} />
                ) : (
                  <div style={{ width: "100%", height: "100%", background: "#ccc", color: "#fff", display: "flex", alignItems: "center", justifyContent: "center", fontSize: "1.2rem" }}>👤</div>
                )}
              </div>
              {isMobileMenuOpen && <span style={{ fontWeight: "bold", fontSize: "1rem" }}>ダッシュボードへ</span>}
            </Link>
            <button onClick={() => { handleLogout(); setIsMobileMenuOpen(false); }} className="btn btn-ghost" style={{ fontSize: "0.9rem", padding: isMobileMenuOpen ? "12px 0" : "8px 16px", textAlign: isMobileMenuOpen ? "left" : "center", width: isMobileMenuOpen ? "100%" : "auto" }}>ログアウト</button>
          </div>
        ) : (
          <Link 
            href="/login" 
            onClick={() => setIsMobileMenuOpen(false)} 
            className="btn btn-primary" 
            style={{ 
              padding: isMobileMenuOpen ? "12px 0" : "8px 20px", 
              width: isMobileMenuOpen ? "100%" : "auto", 
              display: "block", 
              textAlign: "center",
              marginTop: isMobileMenuOpen ? "16px" : "0",
              fontWeight: "bold"
            }}
          >
            ログイン / 登録
          </Link>
        )}
      </div>
    </div>
  );

  return (
    <>
      <header className="site-header">
        <div className="container header-inner" style={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
          <Link href="/" className="logo-wrap" style={{ textDecoration: 'none' }}>
            <div className="logo-mark">C</div>
            <div className="logo-text-block"><div className="logo-text-main">Castket</div><div className="logo-text-sub">VRChat Event Platform</div></div>
          </Link>
          <div className="pc-menu" style={{ display: "flex", alignItems: "center" }}>
            <MenuContent />
          </div>
          <button className="mobile-menu-btn" onClick={() => setIsMobileMenuOpen(true)}>
              <span style={{ fontSize: "1.5rem" }}>≡</span>
          </button>
        </div>
      </header>

      {isMobileMenuOpen && (
        <div className="mobile-menu-overlay">
          <div className="mobile-menu-content">
              <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: "32px", borderBottom: "1px solid #eee", paddingBottom: "16px" }}>
                <span style={{ fontWeight: "bold", fontSize: "1.2rem" }}>Menu</span>
                <button onClick={() => setIsMobileMenuOpen(false)} style={{ background: "none", border: "none", fontSize: "1.8rem", cursor: "pointer", padding: "0 8px" }}>×</button>
              </div>
              <MenuContent />
          </div>
        </div>
      )}

      <main>
        <section className="hero-section">
          <div className="hero-bg-container">
            {HERO_IMAGES.map((src, index) => (
              <div key={index} className={`hero-bg-slide ${index === currentHeroIndex ? "active" : ""}`} style={{ backgroundImage: `url(${src})` }} />
            ))}
            <div className="hero-overlay"></div>
          </div>
          <div className="container hero-content">
            <h1 className="hero-title animate-fade-up">キミの<span className="text-gradient">「舞台」</span>は、<br/>ココで見つかる。</h1>
            <p className="hero-subtitle animate-fade-up delay-200"><span className="text-highlight">イベントクリエイターとパフォーマーをつなぐ</span><br className="mobile-break" /><span className="text-highlight">VRChat特化型キャスティング・ハブ「Castket」</span></p>
            <div className="hero-btn-container">
              <Link href="/events" className="hero-btn btn-event">📅 イベントを探す</Link>
              <Link href="/casts" className="hero-btn btn-cast">✨ キャストを探す</Link>
            </div>
          </div>
        </section>

        {/* 以前ここにあった How to Use セクションは削除済み */}

        <div className="container section">
          {newsList.length > 0 && (
            <div style={{ marginBottom: "60px" }}>
              <h2 className="section-title" style={{ textAlign: "left", fontSize: "1.2rem", marginBottom: "16px" }}>📢 お知らせ</h2>
              <div className="card" style={{ padding: "8px 24px" }}>
                <ul style={{ listStyle: "none", padding: 0, margin: 0 }}>
                  {newsList.map((news) => (
                    <li key={news.id} style={{ borderBottom: "1px solid #eee", padding: "12px 0", display: "flex", flexWrap: "wrap", gap: "12px", alignItems: "baseline" }}>
                      <span style={{ fontSize: "0.85rem", color: "var(--muted)", fontFamily: "monospace" }}>{new Date(news.created_at).toLocaleDateString()}</span>
                      {news.url ? <a href={news.url} target="_blank" rel="noopener noreferrer" style={{ textDecoration: "none", color: "var(--text)", fontWeight: "500" }}>{news.title} ↗</a> : <span style={{ fontWeight: "500" }}>{news.title}</span>}
                    </li>
                  ))}
                </ul>
              </div>
            </div>
          )}

          <div className="two-col-grid" style={{ marginBottom: "60px" }}>
            <div>
              <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: "16px" }}><h2 className="section-title" style={{ margin: 0, fontSize: "1.2rem", textAlign: "left" }}>✨ 注目のキャスト</h2><Link href="/casts" style={{ fontSize: "0.85rem", color: "var(--accent)" }}>もっと見る</Link></div>
              <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: "16px" }}>{popularCasts.map(cast => <CastCard key={cast.user_id} cast={cast} />)}</div>
            </div>
            <div>
              <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: "16px" }}><h2 className="section-title" style={{ margin: 0, fontSize: "1.2rem", textAlign: "left" }}>🆕 新着キャスト</h2><Link href="/casts" style={{ fontSize: "0.85rem", color: "var(--accent)" }}>もっと見る</Link></div>
              <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: "16px" }}>{newCasts.map(cast => <CastCard key={cast.user_id} cast={cast} />)}</div>
            </div>
          </div>

          <div className="two-col-grid">
            <div>
              <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: "16px" }}><h2 className="section-title" style={{ margin: 0, fontSize: "1.2rem", textAlign: "left" }}>🔥 注目のイベント</h2><Link href="/events" style={{ fontSize: "0.85rem", color: "var(--accent)" }}>もっと見る</Link></div>
              <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: "16px" }}>{featuredEvents.map(event => <EventCard key={event.id} event={event} />)}</div>
            </div>
            <div>
               <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: "16px" }}><h2 className="section-title" style={{ margin: 0, fontSize: "1.2rem", textAlign: "left" }}>⏳ 開催間近のイベント</h2><Link href="/events" style={{ fontSize: "0.85rem", color: "var(--accent)" }}>もっと見る</Link></div>
              <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: "16px" }}>{upcomingEvents.map(event => <EventCard key={event.id} event={event} />)}</div>
            </div>
          </div>
        </div>
      </main>

      <footer style={{ background: "#333", color: "#fff", padding: "60px 20px", marginTop: "60px" }}>
        <div className="container" style={{ textAlign: "center" }}>
          <div style={{ fontSize: "1.5rem", fontWeight: "bold", marginBottom: "16px" }}>Castket</div>
          <p style={{ color: "#aaa", fontSize: "0.9rem" }}>Created for VRChat Community</p>
          <div style={{ marginTop: "32px", color: "#666", fontSize: "0.8rem" }}>&copy; 2026 Castket All rights reserved.</div>
        </div>
      </footer>

      <style jsx>{`
        .mobile-menu-btn { display: none; background: none; border: none; cursor: pointer; color: #333; }
        .mobile-menu-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999; }
        .mobile-menu-content { position: absolute; top: 0; right: 0; width: 85%; max-width: 320px; height: 100%; background: #fff; padding: 24px; box-shadow: -4px 0 10px rgba(0,0,0,0.1); display: flex; flexDirection: column; }
        
        @media (max-width: 768px) {
          .pc-menu { display: none !important; }
          .mobile-menu-btn { display: block !important; }
        }

        .header-avatar-container { transition: transform 0.2s; cursor: pointer; }
        .header-avatar-container:hover { transform: scale(1.1); border-color: var(--accent); }
        
        .two-col-grid { display: grid; grid-template-columns: 1fr; gap: 40px; }
        @media (min-width: 768px) { .two-col-grid { grid-template-columns: 1fr 1fr; } }
      `}</style>
    </>
  );
}


----------------------------------------
### FILE: AvatarUpload.tsx ###
----------------------------------------
"use client";

import { useState } from "react";
import { supabase } from "@/lib/supabase";
import imageCompression from "browser-image-compression";
import toast from "react-hot-toast";

// ↓ userIdを受け取るように変更されているか確認！
type Props = {
  userId: string;
  url: string | null;
  onUpload: (url: string) => void;
};

export default function AvatarUpload({ userId, url, onUpload }: Props) {
  const [uploading, setUploading] = useState(false);
  const [previewUrl, setPreviewUrl] = useState<string | null>(url);

  const handleFileChange = async (event: React.ChangeEvent<HTMLInputElement>) => {
    try {
      setUploading(true);

      if (!event.target.files || event.target.files.length === 0) {
        throw new Error("画像を選択してください。");
      }

      const originalFile = event.target.files[0];

      // 圧縮設定
      const options = {
        maxSizeMB: 0.1,
        maxWidthOrHeight: 500,
        useWebWorker: true,
        fileType: "image/jpeg"
      };

      let compressedFile;
      try {
        compressedFile = await imageCompression(originalFile, options);
      } catch (error) {
        console.error("圧縮失敗", error);
        compressedFile = originalFile;
      }

      // 【重要】ここが修正ポイント！
      // ランダムな名前ではなく、ユーザーIDを使った固定の名前にする
      const filePath = `${userId}/avatar.jpg`;

      // 上書き許可 (upsert: true) でアップロード
      const { error: uploadError } = await supabase.storage
        .from("avatars")
        .upload(filePath, compressedFile, {
          upsert: true, 
        });

      if (uploadError) {
        throw uploadError;
      }

      // 公開URLを取得
      const { data } = supabase.storage
        .from("avatars")
        .getPublicUrl(filePath);
      
      // キャッシュ対策で時刻をつける
      const publicUrl = `${data.publicUrl}?t=${Date.now()}`;

      setPreviewUrl(publicUrl);
      onUpload(publicUrl);

    } catch (error: any) {
      toast.error(error.message);
    } finally {
      setUploading(false);
    }
  };

  return (
    <div style={{ display: "flex", flexDirection: "column", alignItems: "center", gap: "12px" }}>
      <div
        style={{
          width: "100px",
          height: "100px",
          borderRadius: "50%",
          overflow: "hidden",
          background: "var(--bg)",
          border: "2px solid var(--border)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          position: "relative",
        }}
      >
        {previewUrl ? (
          // eslint-disable-next-line @next/next/no-img-element
          <img
            src={previewUrl}
            alt="Avatar"
            style={{ width: "100%", height: "100%", objectFit: "cover" }}
          />
        ) : (
          <span style={{ color: "var(--muted)", fontSize: "2rem" }}>?</span>
        )}
        {uploading && (
          <div style={{ position: "absolute", inset: 0, background: "rgba(255,255,255,0.7)", display: "flex", alignItems: "center", justifyContent: "center" }}>
            <span style={{ fontSize: "0.8rem", fontWeight: "bold", color: "var(--accent)" }}>UP中...</span>
          </div>
        )}
      </div>

      <div>
        <label className="btn btn-secondary" style={{ cursor: "pointer", fontSize: "0.8rem", padding: "6px 12px" }}>
          {uploading ? "処理中..." : "画像を変更"}
          <input
            type="file"
            accept="image/*"
            onChange={handleFileChange}
            disabled={uploading}
            style={{ display: "none" }}
          />
        </label>
      </div>
    </div>
  );
}


----------------------------------------
### FILE: BookmarkButton.tsx ###
----------------------------------------
"use client";

import { useState, useEffect } from "react";
import { supabase } from "@/lib/supabase";
// ▼ 追加
import BookmarkModal from "./BookmarkModal";

type Props = {
  targetId: string | number;
  targetType: "event" | "cast";
  userId?: string;
  targetName?: string; // ▼ 追加: モダールに名前を出すため
};

export default function BookmarkButton({ targetId, targetType, userId, targetName = "このユーザー" }: Props) {
  const [isBookmarked, setIsBookmarked] = useState(false);
  const [loading, setLoading] = useState(false);
  
  // ▼ 追加: モダール開閉用
  const [isModalOpen, setIsModalOpen] = useState(false);

  // 初期状態チェック
  const checkBookmark = async () => {
    if (!userId) return;
    const table = targetType === "event" ? "event_bookmarks" : "cast_bookmarks";
    const idColumn = targetType === "event" ? "event_id" : "target_cast_id";

    const { data } = await supabase
      .from(table)
      .select("id")
      .eq("user_id", userId)
      .eq(idColumn, targetId)
      .maybeSingle();
    
    setIsBookmarked(!!data);
  };

  useEffect(() => {
    checkBookmark();
  }, [userId, targetId, targetType]);

  const handleClick = async () => {
    if (!userId) {
      alert("保存するにはログインが必要です");
      return;
    }

    // ★キャストの場合はモダールを開く
    if (targetType === "cast") {
      setIsModalOpen(true);
      return;
    }

    // --- 以下はイベント用の既存ロジック（そのまま） ---
    if (loading) return;
    setLoading(true);

    try {
      if (isBookmarked) {
        await supabase.from("event_bookmarks").delete().eq("user_id", userId).eq("event_id", targetId);
        setIsBookmarked(false);
      } else {
        await supabase.from("event_bookmarks").insert({ user_id: userId, event_id: targetId });
        setIsBookmarked(true);
      }
    } catch (error) {
      console.error(error);
      alert("エラーが発生しました");
    } finally {
      setLoading(false);
    }
  };

  return (
    <>
      <button 
        onClick={handleClick}
        style={{
          background: isBookmarked ? "#333" : "#f0f0f0",
          color: isBookmarked ? "#fff" : "#333",
          border: "none",
          borderRadius: "99px",
          padding: "8px 16px",
          cursor: "pointer",
          display: "flex",
          alignItems: "center",
          gap: "6px",
          fontWeight: "bold",
          fontSize: "0.9rem",
          transition: "all 0.2s"
        }}
      >
        <span>{isBookmarked ? "🔖 保存済み" : "🔖 保存する"}</span>
      </button>

      {/* ▼ キャスト用モダール */}
      {targetType === "cast" && userId && (
        <BookmarkModal 
          isOpen={isModalOpen} 
          onClose={() => setIsModalOpen(false)}
          targetId={targetId as string}
          targetName={targetName}
          userId={userId}
          onUpdate={checkBookmark} // 保存後に状態を再確認
        />
      )}
    </>
  );
}


----------------------------------------
### FILE: BookmarkModal.tsx ###
----------------------------------------
"use client";

import { useState, useEffect } from "react";
import { supabase } from "@/lib/supabase";
import toast from "react-hot-toast";

type Props = {
  isOpen: boolean;
  onClose: () => void;
  targetId: string; // キャストのユーザーID
  targetName: string; // キャストの名前
  userId: string;   // 自分のID
  onUpdate?: () => void; // 更新後のコールバック（ダッシュボード用）
};

export default function BookmarkModal({ isOpen, onClose, targetId, targetName, userId, onUpdate }: Props) {
  const [memo, setMemo] = useState("");
  const [isBookmarked, setIsBookmarked] = useState(false);
  const [loading, setLoading] = useState(false);
  const [fetching, setFetching] = useState(true);

  // モダールが開いたときに現状のデータを取得
  useEffect(() => {
    if (isOpen && userId && targetId) {
      setFetching(true);
      const checkStatus = async () => {
        const { data } = await supabase
          .from("cast_bookmarks")
          .select("memo")
          .eq("user_id", userId)
          .eq("target_cast_id", targetId)
          .maybeSingle();

        if (data) {
          setIsBookmarked(true);
          setMemo(data.memo || "");
        } else {
          setIsBookmarked(false);
          setMemo("");
        }
        setFetching(false);
      };
      checkStatus();
    }
  }, [isOpen, userId, targetId]);

  const handleSave = async () => {
    setLoading(true);
    try {
      // upsert: なければ作成、あれば更新（メモも保存）
      const { error } = await supabase
        .from("cast_bookmarks")
        .upsert({ 
          user_id: userId, 
          target_cast_id: targetId,
          memo: memo 
        }, { onConflict: 'user_id, target_cast_id' });

      if (error) throw error;

      toast.success(isBookmarked ? "メモを更新しました！" : "ブックマークしました！");
      if (onUpdate) onUpdate();
      onClose();
    } catch (e: any) {
      toast.error("エラー: " + e.message);
    } finally {
      setLoading(false);
    }
  };

  const handleRemove = async () => {
    if (!confirm("ブックマークを解除しますか？")) return;
    setLoading(true);
    try {
      const { error } = await supabase
        .from("cast_bookmarks")
        .delete()
        .eq("user_id", userId)
        .eq("target_cast_id", targetId);

      if (error) throw error;

      toast.success("ブックマークを解除しました");
      if (onUpdate) onUpdate();
      onClose();
    } catch (e: any) {
      toast.error("エラー: " + e.message);
    } finally {
      setLoading(false);
    }
  };

  if (!isOpen) return null;

  return (
    <div style={{
      position: "fixed", top: 0, left: 0, width: "100%", height: "100%",
      backgroundColor: "rgba(0,0,0,0.5)", display: "flex", alignItems: "center", justifyContent: "center", zIndex: 1100
    }}>
      <div className="card" style={{ width: "90%", maxWidth: "400px", background: "#fff", padding: "24px", position: "relative" }}>
        <button onClick={onClose} style={{ position: "absolute", top: "12px", right: "12px", background: "none", border: "none", fontSize: "1.2rem", cursor: "pointer" }}>×</button>
        
        <h3 style={{ fontSize: "1.1rem", marginBottom: "16px" }}>
          🔖 {targetName} さんを記録
        </h3>

        {fetching ? (
          <div style={{ textAlign: "center", padding: "20px" }}>読み込み中...</div>
        ) : (
          <>
            <div style={{ marginBottom: "16px" }}>
              <label style={{ display: "block", marginBottom: "8px", fontWeight: "bold", fontSize: "0.9rem" }}>メモ (任意)</label>
              <textarea
                rows={4}
                value={memo}
                onChange={(e) => setMemo(e.target.value)}
                placeholder="例：歌声が素敵だった。次回の音楽イベントに誘いたい。"
                style={{ width: "100%", padding: "10px", borderRadius: "8px", border: "1px solid #ddd", fontFamily: "inherit" }}
              />
            </div>

            <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
              {isBookmarked ? (
                <button onClick={handleRemove} className="btn" style={{ background: "#fee2e2", color: "#ef4444", fontSize: "0.9rem" }} disabled={loading}>
                  🗑 解除
                </button>
              ) : (
                <div></div> /* スペース調整用 */
              )}
              
              <div style={{ display: "flex", gap: "8px" }}>
                <button onClick={onClose} className="btn btn-ghost">キャンセル</button>
                <button onClick={handleSave} className="btn btn-primary" disabled={loading}>
                  {loading ? "処理中..." : "保存する"}
                </button>
              </div>
            </div>
          </>
        )}
      </div>
    </div>
  );
}


----------------------------------------
### FILE: CastLikeButton.tsx ###
----------------------------------------
"use client";

import { useState } from "react";
import { supabase } from "@/lib/supabase";

type Props = {
  castId: string;      // キャスト(ユーザー)のID
  userId?: string;     // 今ログインしている人のID
  initialIsLiked: boolean;
  initialCount: number;
};

export default function CastLikeButton({ castId, userId, initialIsLiked, initialCount }: Props) {
  const [isLiked, setIsLiked] = useState(initialIsLiked);
  const [count, setCount] = useState(initialCount);
  const [isLoading, setIsLoading] = useState(false);

  const toggleLike = async () => {
    // 自分のIDと相手のIDが同じなら押せないようにする
    if (userId === castId) {
      alert("自分にはいいねできません");
      return;
    }
    if (!userId) {
      alert("応援するにはログインが必要です");
      return;
    }
    if (isLoading) return;

    setIsLoading(true);
    
    const nextIsLiked = !isLiked;
    setIsLiked(nextIsLiked);
    setCount((prev) => nextIsLiked ? prev + 1 : prev - 1);

    try {
      if (nextIsLiked) {
        // いいね登録
        const { error } = await supabase
          .from("profile_likes")
          .insert({ user_id: userId, target_cast_id: castId });
        if (error) throw error;
      } else {
        // いいね解除
        const { error } = await supabase
          .from("profile_likes")
          .delete()
          .eq("user_id", userId)
          .eq("target_cast_id", castId);
        if (error) throw error;
      }
    } catch (error) {
      console.error("Like Error:", error);
      setIsLiked(!nextIsLiked);
      setCount((prev) => nextIsLiked ? prev - 1 : prev + 1);
      alert("通信エラーが発生しました");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <button 
      onClick={toggleLike}
      className={`like-btn ${isLiked ? "liked" : ""}`}
      style={{
        display: "flex",
        alignItems: "center",
        gap: "6px",
        padding: "8px 16px",
        border: `1px solid ${isLiked ? "#ff4757" : "#ddd"}`,
        borderRadius: "99px",
        background: isLiked ? "#fff0f1" : "#fff",
        color: isLiked ? "#ff4757" : "#666",
        fontWeight: "bold",
        cursor: isLoading ? "wait" : "pointer",
        transition: "all 0.2s",
        fontSize: "0.9rem"
      }}
    >
      <span style={{ fontSize: "1.1rem" }}>
        {isLiked ? "💖" : "🤍"} 
      </span>
      <span>{count}</span>
      
      <style jsx>{`
        .like-btn:hover { transform: scale(1.05); }
        .like-btn:active { transform: scale(0.95); }
      `}</style>
    </button>
  );
}


----------------------------------------
### FILE: EventBannerUpload.tsx ###
----------------------------------------
"use client";

import { useState } from "react";
import { supabase } from "@/lib/supabase";
import imageCompression from "browser-image-compression"; // 圧縮ライブラリをインポート

export default function EventBannerUpload({ userId, url, onUpload }: { userId: string, url: string, onUpload: (url: string) => void }) {
  const [uploading, setUploading] = useState(false);

  const uploadBanner = async (event: React.ChangeEvent<HTMLInputElement>) => {
    try {
      setUploading(true);

      if (!event.target.files || event.target.files.length === 0) {
        throw new Error("画像を選択してください");
      }

      const file = event.target.files[0];

      // ▼▼▼ 圧縮設定（フルHDサイズ、最大1MB） ▼▼▼
      const options = {
        maxSizeMB: 1,
        maxWidthOrHeight: 1920,
        useWebWorker: true,
      };

      // 圧縮を実行
      const compressedFile = await imageCompression(file, options);
      // ▲▲▲ 圧縮完了 ▲▲▲

      // ファイル名をランダムにして重複を防ぐ
      const fileExt = file.name.split(".").pop();
      const fileName = `${userId}/${Math.random()}.${fileExt}`;
      const filePath = `${fileName}`;

      // 'events' バケットにアップロード（圧縮後のファイルを使用）
      const { error: uploadError } = await supabase.storage
        .from("event-banners") // ※もしバケット名が違う場合はここを修正してください
        .upload(filePath, compressedFile);

      if (uploadError) {
        throw uploadError;
      }

      // 公開URLを取得
      const { data } = supabase.storage.from("event-banners").getPublicUrl(filePath);
      
      onUpload(data.publicUrl);
    } catch (error: any) {
      alert("アップロードエラー: " + error.message);
    } finally {
      setUploading(false);
    }
  };

  return (
    <div style={{ marginBottom: "16px" }}>
      {/* プレビュー表示エリア */}
      <div style={{ 
        width: "100%", 
        aspectRatio: "16/9", 
        backgroundColor: "#f0f0f0", 
        borderRadius: "8px", 
        overflow: "hidden", 
        marginBottom: "8px",
        position: "relative",
        border: "1px solid #ddd",
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
      }}>
        {url ? (
          // eslint-disable-next-line @next/next/no-img-element
          <img 
            src={url} 
            alt="Event Banner" 
            style={{ width: "100%", height: "100%", objectFit: "cover" }} 
          />
        ) : (
          <span style={{ color: "#aaa", fontSize: "0.9rem", fontWeight: "bold" }}>NO IMAGE</span>
        )}
        
        {uploading && (
          <div style={{ position: "absolute", inset: 0, background: "rgba(255,255,255,0.7)", display: "flex", alignItems: "center", justifyContent: "center" }}>
            <span>圧縮＆UP中...</span>
          </div>
        )}
      </div>

      <div style={{ textAlign: "right" }}>
        <label className="btn btn-secondary" style={{ cursor: "pointer", fontSize: "0.85rem", padding: "4px 12px" }}>
          {uploading ? "処理中..." : "🖼 画像を変更"}
          <input
            type="file"
            accept="image/*"
            onChange={uploadBanner}
            disabled={uploading}
            style={{ display: "none" }}
          />
        </label>
      </div>
    </div>
  );
}


----------------------------------------
### FILE: LikeButton.tsx ###
----------------------------------------
"use client";

import { useState } from "react";
import { supabase } from "@/lib/supabase";

type Props = {
  eventId: string;
  userId?: string;     // ログインしてない場合もあるので ? をつける
  initialIsLiked: boolean;
  initialCount: number;
};

export default function LikeButton({ eventId, userId, initialIsLiked, initialCount }: Props) {
  const [isLiked, setIsLiked] = useState(initialIsLiked);
  const [count, setCount] = useState(initialCount);
  const [isLoading, setIsLoading] = useState(false);

  const toggleLike = async () => {
    if (!userId) {
      alert("いいねするにはログインが必要です");
      return;
    }
    if (isLoading) return;

    setIsLoading(true);
    
    // UIを先に更新（サクサク動くように見せる）
    const nextIsLiked = !isLiked;
    setIsLiked(nextIsLiked);
    setCount((prev) => nextIsLiked ? prev + 1 : prev - 1);

    try {
      if (nextIsLiked) {
        // いいね登録
        const { error } = await supabase
          .from("likes")
          .insert({ user_id: userId, event_id: eventId });
        if (error) throw error;
      } else {
        // いいね解除
        const { error } = await supabase
          .from("likes")
          .delete()
          .eq("user_id", userId)
          .eq("event_id", eventId);
        if (error) throw error;
      }
    } catch (error) {
      console.error("Like Error:", error);
      // エラーが出たら見た目を元に戻す
      setIsLiked(!nextIsLiked);
      setCount((prev) => nextIsLiked ? prev - 1 : prev + 1);
      alert("通信エラーが発生しました");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <button 
      onClick={toggleLike}
      className={`like-btn ${isLiked ? "liked" : ""}`}
      style={{
        display: "flex",
        alignItems: "center",
        gap: "6px",
        padding: "8px 16px",
        border: `1px solid ${isLiked ? "#ff4757" : "#ddd"}`,
        borderRadius: "99px",
        background: isLiked ? "#fff0f1" : "#fff",
        color: isLiked ? "#ff4757" : "#666",
        fontWeight: "bold",
        cursor: isLoading ? "wait" : "pointer",
        transition: "all 0.2s",
        fontSize: "1rem"
      }}
    >
      <span style={{ fontSize: "1.2rem" }}>
        {isLiked ? "❤️" : "🤍"}
      </span>
      <span>{count}</span>
      
      <style jsx>{`
        .like-btn:hover { transform: scale(1.05); }
        .like-btn:active { transform: scale(0.95); }
      `}</style>
    </button>
  );
}


----------------------------------------
### FILE: NotificationListener.tsx ###
----------------------------------------
"use client";

import { useEffect, useRef } from "react";
import useSWR from "swr";
import { supabase } from "@/lib/supabase";
import toast from "react-hot-toast";
import { useRouter } from "next/navigation";

// データ取得関数
const fetchNotificationCounts = async () => {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return null;

  // 1. 【オファー】自分宛ての「返信待ち」オファー数
  const { count: offerCount } = await supabase
    .from("offers")
    .select("*", { count: "exact", head: true })
    .eq("receiver_id", user.id)
    .eq("status", "pending"); // ★ここ重要！未対応のものだけ数える

  // 2. 【応募】自分が主催しているイベントへの「承認待ち」参加者数
  // ステップA: 自分が主催者のイベントIDを全部取得
  const { data: myEvents } = await supabase
    .from("events")
    .select("id")
    .eq("organizer_id", user.id);
  
  let appCount = 0;

  // ステップB: そのイベントへの応募数（entriesテーブル）を数える
  if (myEvents && myEvents.length > 0) {
    const eventIds = myEvents.map(e => e.id);
    
    // ※ テーブル名が "entries" か "event_participants" か確認してください。
    // ダッシュボードの実装に合わせて "entries" としています。
    const { count } = await supabase
      .from("entries") 
      .select("*", { count: "exact", head: true })
      .in("event_id", eventIds)
      .eq("status", "pending"); // ★ここも！対応待ちの人だけ通知
    
    appCount = count || 0;
  }
  
  return { 
    offerCount: offerCount || 0,
    appCount: appCount || 0
  };
};

export default function NotificationListener() {
  const router = useRouter();
  
  // 前回の数を記録する箱
  const prevCountsRef = useRef<{ offer: number | null, app: number | null }>({
    offer: null,
    app: null
  });

  const { data } = useSWR('notification-check', fetchNotificationCounts, {
    refreshInterval: 30000,
    dedupingInterval: 10000, 
    refreshWhenHidden: true,
    refreshWhenOffline: false,
  });

  useEffect(() => {
    if (!data) return;

    // --- 1. 初回ロード時 ---
    if (prevCountsRef.current.offer === null) {
      prevCountsRef.current = { 
        offer: data.offerCount, 
        app: data.appCount 
      };
      return;
    }

    // --- 2. オファーが増えたかチェック ---
    // (未対応のものが増えた＝新しいオファーが来た！)
    if (data.offerCount > (prevCountsRef.current.offer || 0)) {
      toast((t) => (
        <div onClick={() => { router.push("/dashboard"); toast.dismiss(t.id); }} style={{ cursor: "pointer" }}>
          📩 <b>新着オファーが届きました！</b>
          <div style={{ fontSize: "0.80rem" }}>未読: {data.offerCount}件</div>
        </div>
      ), { duration: 6000, icon: '👏' });
    }

    // --- 3. 応募が増えたかチェック ---
    if (data.appCount > (prevCountsRef.current.app || 0)) {
      const diff = data.appCount - (prevCountsRef.current.app || 0);
      toast((t) => (
        <div onClick={() => { router.push("/dashboard"); toast.dismiss(t.id); }} style={{ cursor: "pointer" }}>
          🙋‍♂️ <b>イベントへの応募がありました！</b>
          <div style={{ fontSize: "0.80rem" }}>+{diff}件 の承認待ち</div>
        </div>
      ), { duration: 6000, icon: '🎉' });
    }

    // --- 4. 記録を更新 ---
    // 「対応して数が減った」場合もここで更新されるので、
    // 次にまた増えたらちゃんと通知が出ます。
    prevCountsRef.current = { 
      offer: data.offerCount, 
      app: data.appCount 
    };

  }, [data, router]);

  return null;
}


----------------------------------------
### FILE: OfferModal.tsx ###
----------------------------------------
"use client";

import { useState } from "react";
import { supabase } from "@/lib/supabase";
import toast from "react-hot-toast";

type OfferModalProps = {
  isOpen: boolean;
  onClose: () => void;
  castId: string;        // 相手のID
  castName: string;      // 相手の名前
  myEvents: any[];       // 自分が主催しているイベントのリスト
  currentUserId: string; // 自分のID
};

export default function OfferModal({ isOpen, onClose, castId, castName, myEvents, currentUserId }: OfferModalProps) {
  const [selectedEventId, setSelectedEventId] = useState("");
  const [message, setMessage] = useState("");
  const [loading, setLoading] = useState(false);

  if (!isOpen) return null;

  const handleSendOffer = async () => {
    if (!selectedEventId) return toast.error("イベントを選択してください");
    
    setLoading(true);
    try {

const { data: existingOffers } = await supabase
        .from("offers")
        .select("id")
        .eq("event_id", selectedEventId)
        .eq("receiver_id", castId)
        .eq("status", "pending")
        .limit(1); // 1件でもあればOK

      // 配列の中身があるかチェック
      if (existingOffers && existingOffers.length > 0) {
        toast.error("このイベントのオファーは既に送信済みです！\n返信をお待ちください。");
        setLoading(false);
        return;
      }

      // ▼▼▼ 追加: クールタイムチェック (断られた場合の再送制限) ▼▼▼
      const COOLDOWN_DAYS = 3; // ★ここで日数を設定 (例: 7日間)

      const { data: rejectedOffer } = await supabase
        .from("offers")
        .select("created_at")
        .eq("event_id", selectedEventId)
        .eq("receiver_id", castId)
        .eq("status", "rejected") // 「見送り」されたものを探す
        .order("created_at", { ascending: false }) // 最新のものを1つ
        .limit(1)
        .single();

      if (rejectedOffer) {
        const lastDate = new Date(rejectedOffer.created_at).getTime();
        const now = new Date().getTime();
        const diffDays = (now - lastDate) / (1000 * 60 * 60 * 24);

        if (diffDays < COOLDOWN_DAYS) {
          const waitDays = Math.ceil(COOLDOWN_DAYS - diffDays);
          toast.error(
            `以前このイベントへのオファーは見送られています。\n再送するには、あと ${waitDays} 日お待ちください。`,
            { duration: 5000 }
          );
          setLoading(false);
          return;
        }
      }
      // ▲▲▲ 追加ここまで ▲▲▲
      
      const { error } = await supabase.from("offers").insert({
        event_id: selectedEventId,
        sender_id: currentUserId,
        receiver_id: castId,
        message: message,
        status: "pending"
      });

      if (error) throw error;

      toast.success("オファーを送信しました！");
      onClose(); // 閉じる
      setMessage(""); // リセット
    } catch (err: any) {
      toast.error("エラー: " + err.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div style={{
      position: "fixed", top: 0, left: 0, width: "100%", height: "100%",
      backgroundColor: "rgba(0,0,0,0.5)", display: "flex", alignItems: "center", justifyContent: "center", zIndex: 1000
    }}>
      <div className="card" style={{ width: "90%", maxWidth: "500px", background: "#fff", padding: "24px" }}>
        <h3 style={{ fontSize: "1.2rem", marginBottom: "16px" }}>
          ✨ {castName} さんへオファー
        </h3>

        {myEvents.length === 0 ? (
          <div style={{ textAlign: "center", padding: "20px" }}>
            <p>主催しているイベントがありません。<br/>まずはイベントを作成してください。</p>
            <button className="btn btn-ghost" onClick={onClose} style={{ marginTop: "10px" }}>閉じる</button>
          </div>
        ) : (
          <>
            <div style={{ marginBottom: "16px" }}>
              <label style={{ display: "block", marginBottom: "8px", fontWeight: "bold" }}>どのイベントに招待しますか？</label>
              <select 
                value={selectedEventId} 
                onChange={(e) => setSelectedEventId(e.target.value)}
                style={{ width: "100%", padding: "10px", borderRadius: "8px", border: "1px solid #ddd" }}
              >
                <option value="">イベントを選択...</option>
                {myEvents.map(ev => (
                  <option key={ev.id} value={ev.id}>{ev.title}</option>
                ))}
              </select>
            </div>

            <div style={{ marginBottom: "24px" }}>
              <label style={{ display: "block", marginBottom: "8px", fontWeight: "bold" }}>メッセージ (任意)</label>
              <textarea 
                rows={4}
                value={message}
                onChange={(e) => setMessage(e.target.value)}
                placeholder="例：ぜひメインキャストとして出演していただきたいです！"
                style={{ width: "100%", padding: "10px", borderRadius: "8px", border: "1px solid #ddd" }}
              />
            </div>

            <div style={{ display: "flex", justifyContent: "flex-end", gap: "10px" }}>
              <button className="btn btn-ghost" onClick={onClose} disabled={loading}>キャンセル</button>
              <button className="btn btn-primary" onClick={handleSendOffer} disabled={loading || !selectedEventId}>
                {loading ? "送信中..." : "オファーを送る"}
              </button>
            </div>
          </>
        )}
      </div>
    </div>
  );
}


----------------------------------------
### FILE: OfferReplyModal.tsx ###
----------------------------------------
"use client";

import { useState } from "react";
import { supabase } from "@/lib/supabase";
import toast from "react-hot-toast";

type OfferReplyModalProps = {
  isOpen: boolean;
  onClose: () => void;
  offer: any;            // 選択されたオファーデータ
  onUpdate: () => void;  // 更新後に親画面をリフレッシュする関数
};

export default function OfferReplyModal({ isOpen, onClose, offer, onUpdate }: OfferReplyModalProps) {
  const [loading, setLoading] = useState(false);

  if (!isOpen || !offer) return null;

  // オファーへの返信処理
  const handleRespond = async (status: "accepted" | "rejected") => {
    if (!confirm(status === "accepted" ? "オファーを承諾しますか？" : "本当に辞退しますか？")) return;

    setLoading(true);
    try {
      // 1. オファーのステータスを更新
      const { error } = await supabase
        .from("offers")
        .update({ status: status })
        .eq("id", offer.id);

      if (error) throw error;

      // (将来的にはここで entries テーブルにも追加すると完璧ですが、まずはオファー状況の更新だけでOK)

      toast.success(status === "accepted" ? "オファーを承諾しました！🎉" : "オファーを辞退しました。");
      onUpdate(); // ダッシュボードを更新
      onClose();  // 閉じる
    } catch (err: any) {
      toast.error("エラー: " + err.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div style={{
      position: "fixed", top: 0, left: 0, width: "100%", height: "100%",
      backgroundColor: "rgba(0,0,0,0.5)", display: "flex", alignItems: "center", justifyContent: "center", zIndex: 1000
    }}>
      <div className="card" style={{ width: "90%", maxWidth: "500px", background: "#fff", padding: "32px", position: "relative" }}>
        {/* 閉じるボタン */}
        <button onClick={onClose} style={{ position: "absolute", top: "16px", right: "16px", background: "none", border: "none", fontSize: "1.5rem", cursor: "pointer" }}>×</button>

        <h3 style={{ fontSize: "1.2rem", marginBottom: "24px", textAlign: "center" }}>📩 オファー内容の確認</h3>

        <div style={{ marginBottom: "24px", textAlign: "center" }}>
          <div style={{ width: "80px", height: "80px", borderRadius: "50%", background: "#eee", overflow: "hidden", margin: "0 auto 12px" }}>
            {offer.sender?.avatar_url && <img src={offer.sender.avatar_url} style={{ width: "100%", height: "100%", objectFit: "cover" }} />}
          </div>
          <div style={{ fontWeight: "bold", fontSize: "1.1rem" }}>{offer.sender?.display_name} さんより</div>
          <div style={{ color: "var(--muted)", fontSize: "0.9rem" }}>イベントへの出演依頼</div>
        </div>

        <div style={{ background: "#f9f9f9", padding: "16px", borderRadius: "8px", marginBottom: "24px" }}>
          <div style={{ fontSize: "0.85rem", color: "var(--muted)", marginBottom: "4px" }}>対象イベント</div>
          <div style={{ fontWeight: "bold", marginBottom: "16px", fontSize: "1.1rem" }}>{offer.event?.title}</div>
          
          <div style={{ fontSize: "0.85rem", color: "var(--muted)", marginBottom: "4px" }}>メッセージ</div>
          <div style={{ whiteSpace: "pre-wrap", lineHeight: 1.6 }}>{offer.message || "(メッセージはありません)"}</div>
        </div>

        {/* アクションボタン (ステータスが pending の時だけ表示) */}
        {offer.status === "pending" ? (
          <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: "16px" }}>
            <button 
              className="btn" 
              style={{ background: "#eee", color: "#333" }}
              onClick={() => handleRespond("rejected")}
              disabled={loading}
            >
              辞退する
            </button>
            <button 
              className="btn btn-primary"
              onClick={() => handleRespond("accepted")}
              disabled={loading}
            >
              承諾する
            </button>
          </div>
        ) : (
          <div style={{ textAlign: "center", padding: "12px", background: offer.status === "accepted" ? "#d1fae5" : "#f3f4f6", borderRadius: "8px", color: offer.status === "accepted" ? "#065f46" : "#374151", fontWeight: "bold" }}>
            {offer.status === "accepted" ? "✅ このオファーは承諾済みです" : "🚫 このオファーは辞退しました"}
          </div>
        )}
      </div>
    </div>
  );
}


----------------------------------------
### FILE: ProfileBannerUpload.tsx ###
----------------------------------------
"use client";

import { useState } from "react";
import { supabase } from "@/lib/supabase";
import imageCompression from "browser-image-compression"; // 圧縮ライブラリを追加

export default function ProfileBannerUpload({ userId, url, onUpload }: { userId: string, url: string, onUpload: (url: string) => void }) {
  const [uploading, setUploading] = useState(false);

  const uploadBanner = async (event: React.ChangeEvent<HTMLInputElement>) => {
    try {
      setUploading(true);

      if (!event.target.files || event.target.files.length === 0) {
        throw new Error("画像を選択してください");
      }

      const file = event.target.files[0];

      // ▼▼▼ 圧縮設定 ▼▼▼
      const options = {
        maxSizeMB: 1,          // 最大1MB程度に圧縮
        maxWidthOrHeight: 1920, // 幅か高さを最大1920pxに制限
        useWebWorker: true,
      };

      // 圧縮を実行
      const compressedFile = await imageCompression(file, options);
      // ▲▲▲ 圧縮完了 ▲▲▲

      // ファイル名をランダムにして重複を防ぐ
      const fileExt = file.name.split(".").pop();
      const fileName = `${userId}/banner-${Math.random()}.${fileExt}`;
      const filePath = `${fileName}`;

      // avatarsバケットにアップロード（圧縮後の compressedFile を使う！）
      const { error: uploadError } = await supabase.storage
        .from("avatars")
        .upload(filePath, compressedFile, { upsert: true });

      if (uploadError) {
        throw uploadError;
      }

      const { data } = supabase.storage.from("avatars").getPublicUrl(filePath);
      
      onUpload(data.publicUrl);
    } catch (error: any) {
      alert("アップロードエラー: " + error.message);
    } finally {
      setUploading(false);
    }
  };

  return (
    <div style={{ marginBottom: "16px" }}>
      {/* プレビュー表示エリア */}
      <div style={{ 
        width: "100%", 
        aspectRatio: "3/1", 
        backgroundColor: "#f0f0f0", 
        borderRadius: "8px", 
        overflow: "hidden", 
        marginBottom: "8px",
        position: "relative",
        border: "1px solid #ddd",
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
      }}>
        {url ? (
          // eslint-disable-next-line @next/next/no-img-element
          <img 
            src={url} 
            alt="Profile Banner" 
            style={{ width: "100%", height: "100%", objectFit: "cover" }} 
          />
        ) : (
          <span style={{ color: "#aaa", fontSize: "0.9rem", fontWeight: "bold" }}>NO BANNER</span>
        )}
        
        {uploading && (
          <div style={{ position: "absolute", inset: 0, background: "rgba(255,255,255,0.7)", display: "flex", alignItems: "center", justifyContent: "center" }}>
            <span>圧縮＆UP中...</span>
          </div>
        )}
      </div>

      <div style={{ textAlign: "right" }}>
        <label className="btn btn-secondary" style={{ cursor: "pointer", fontSize: "0.85rem", padding: "4px 12px" }}>
          {uploading ? "処理中..." : "🖼 バナーを変更"}
          <input
            type="file"
            accept="image/*"
            onChange={uploadBanner}
            disabled={uploading}
            style={{ display: "none" }}
          />
        </label>
      </div>
    </div>
  );
}


----------------------------------------
### FILE: constants.ts ###
----------------------------------------
// アプリ全体で使う「ロールの選択肢」をここで一元管理します
export const ROLE_OPTIONS = [
{ value: "Organizer", label: "イベント主催" },
  { value: "Cast",      label: "接客・キャスト" }, // SingerからCastに変更推奨
  { value: "Staff",     label: "運営スタッフ" },   // DJからStaffに変更
  { value: "DJ",        label: "DJ" },            // MusicianからDJに変更
  { value: "Performer", label: "パフォーマー" },   // DancerからPerformerに変更
  { value: "Photographer", label: "カメラマン" },  // PerformerからPhotographerに変更
  { value: "Creator",   label: "クリエイター" },   // StaffからCreatorに変更
  { value: "Tech",      label: "技術・ギミック" }, // CreatorからTechに変更
  { value: "Other",     label: "その他" },
];

// 英語の曜日を日本語に変換する辞書
export const WEEKDAY_MAP: { [key: string]: string } = {
  Sun: "日",
  Mon: "月",
  Tue: "火",
  Wed: "水",
  Thu: "木",
  Fri: "金",
  Sat: "土",
};

// イベントのジャンルタグ
export const EVENT_TAGS = [
  "音楽・ライブ",
  "雑談・交流",
  "ゲーム",
  "ロールプレイ",
  "技術・創作",
  "スキルアップ",
  "その他"
];


----------------------------------------
### FILE: supabase.ts ###
----------------------------------------
import { createClient } from '@supabase/supabase-js'

// .env.local に書いた鍵を読み込みます
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY

// ▼ ログ出力用のコード（キーそのものは表示せず、有無だけ確認）
console.log("--- Supabase Client Debug ---");
console.log("URL exists:", !!supabaseUrl); // trueならOK
console.log("KEY exists:", !!supabaseAnonKey); // trueならOK
console.log("KEY length:", supabaseAnonKey ? supabaseAnonKey.length : 0); // 文字数を確認
console.log("-----------------------------");

// キーがない場合はここでエラーを投げて、ログに残るようにする
if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error("Supabaseの環境変数が設定されていません！Vercelの設定を確認してください。");
}

// Supabaseと通信するクライアントを作成してエクスポート（ここ1箇所だけにする！）
export const supabase = createClient(supabaseUrl, supabaseAnonKey)


----------------------------------------
### FILE: middleware.ts ###
----------------------------------------
import { NextRequest, NextResponse } from 'next/server';

export const config = {
  matcher: ['/:path*'], // すべてのページで実行
};

export function middleware(req: NextRequest) {
  // 基本的な認証情報（ここに設定したいIDとPASSを書くこともできますが、環境変数がおすすめ）
  // Vercelの環境変数で設定した値を使います
  const basicAuthUser = process.env.BASIC_AUTH_USER;
  const basicAuthPassword = process.env.BASIC_AUTH_PASSWORD;

  // 環境変数が設定されていない場合は、認証なしで通す（または開発環境など）
  if (!basicAuthUser || !basicAuthPassword) {
    return NextResponse.next();
  }

  const authorizationHeader = req.headers.get('authorization');

  if (authorizationHeader) {
    const authValue = authorizationHeader.split(' ')[1];
    const [user, password] = atob(authValue).split(':');

    if (user === basicAuthUser && password === basicAuthPassword) {
      return NextResponse.next();
    }
  }

  // 認証に失敗、または未入力の場合
  return new NextResponse('Authentication required', {
    status: 401,
    headers: {
      'WWW-Authenticate': 'Basic realm="Secure Area"',
    },
  });
}


